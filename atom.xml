<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yunvoo Blog</title>
  <subtitle>人生如路--&gt;须在荒凉中走出繁华的风景</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yunvoo.com/"/>
  <updated>2016-06-17T09:17:45.040Z</updated>
  <id>http://yunvoo.com/</id>
  
  <author>
    <name>yunvoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yunvoo.com//blog/2016/06/17/hello-world.html"/>
    <id>http://yunvoo.com//blog/2016/06/17/hello-world.html</id>
    <published>2016-06-17T09:17:45.040Z</published>
    <updated>2016-06-17T09:17:45.040Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>读 TCP 协议 RFC-793</title>
    <link href="http://yunvoo.com//blog/2015/09/27/TCP.html"/>
    <id>http://yunvoo.com//blog/2015/09/27/TCP.html</id>
    <published>2015-09-26T16:00:00.000Z</published>
    <updated>2016-06-18T03:56:36.814Z</updated>
    
    <content type="html">&lt;p&gt;TCP被作为一种运行在分组交换网络（以及它们的互联系统）上的高可靠的主机到主机协议。TCP是面向连接的、端到端的通用协议，却对下层协议的假设甚少（可以是多网络环境，只要求一个不可靠的报文服务），一般用于互联网上不同主机的进程间通信。&lt;br&gt;现行协议版本被IETF标准化为&lt;a href=&quot;http://tools.ietf.org/html/rfc793&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC-793&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然TCP主要运行在互联网的IP协议层之上，但原则上，TCP能够在多种通信系统上进行操作，从硬连线连接到分组交换或电路交换系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font size=&quot;5&quot; color=&quot;#FF2D2D&quot;&gt;概述&lt;/font&gt; 

&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;互联网系统元素&lt;/font&gt; 

&lt;p&gt;Internet环境由连接在通过网关互联的网络上的主机组成。为了在不同主机的进程间通信，网络上运行着多层的协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组&lt;/strong&gt; 是主机以及它所在网络上一次交换的数据。 &lt;strong&gt;主机&lt;/strong&gt; 是连在网络上的计算机，是分组的源和目标。 &lt;strong&gt;进程&lt;/strong&gt; 是主机上的活跃元素。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个进程可能需要独立的多个连接，于是每个进程可以有多个端口来和其他进程通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;操作模型&lt;/font&gt; 

&lt;p&gt;进程通过调用TCP（以数据缓存作为参数）进行数据传输。TCP将数据打包为片段（segment），调用互联网模块传输给目标TCP。接收方TCP将每个片段放在接收用户的缓存中，然后提示用户。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP在片段中包括控制信息，被用来确保传输数据的顺序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个TCP模块关联着一个提供本地网络接口的IP模块，该模块将TCP片段打包成IP数据包，并将其路由到目标IP模块或中间网关。为了在本地网络中传输该数据报，它又被嵌入到本地网络分组中。 分组交换继续做打包、分段等其他操作来递送本地网络分组给目标IP模块。&lt;/p&gt;
&lt;p&gt;在网络间的网关上，打开本地网络分组，得到IP数据报。然后决定接下来应该发送该数据报到那个网络。此后，该数据报被打包进适合下一个本地网络的本地网络分组，路由给下一网关或最终目标。&lt;/p&gt;
&lt;p&gt;网关可以根据需要将IP数据报切分成较小的数据报片段。切分后的片段也可能被再次切分。根据IP数据报分片的格式的设计，目标IP模块可以将分片组装为IP数据报。&lt;/p&gt;
&lt;p&gt;目标IP模块将数据报（如果需要，先进行组装）中的数据拿出来，传送给目标TCP模块。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单的模型中仍有很多的细节，比如服务类型。它为网关选择下一个网络的服务参数提供了信息。服务类型包括数据报的优先级，或者安全信息。这些允许主机和网关根据安全考虑，进行多安全层次的操作来分离数据报。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;连接&lt;/font&gt; 

&lt;p&gt;TCP连接用一对socket来标识，且TCP连接可以向两个方向传送数据，即TCP是全双工的。同时每个端口可以任意绑定一个进程，进程只能对属于自己的端口进行初始化。&lt;/p&gt;
&lt;p&gt;每个数据流都需要维护一些状态信息。这些信息（包括socket、序列号、窗口大小）组成一个连接。一个连接用一组socket标识。&lt;/p&gt;
&lt;p&gt;通信之前，双方应该建立一个连接。结束通信后连接被终止或关闭，释放的资源可供他用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了在不可靠的Internet上建立连接和避免错误的连接初始化，TCP采用了握手机制和基于时钟的序列号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;接口&lt;/font&gt; 

&lt;p&gt;TCP应作为操作系统的一个模块。其用户接口包括&lt;code&gt;OPEN&lt;/code&gt;,&lt;code&gt;CLOSE&lt;/code&gt;,&lt;code&gt;SEND&lt;/code&gt;,&lt;code&gt;RECEIVE&lt;/code&gt;,&lt;code&gt;STATUS&lt;/code&gt;。这些调用就像是文件调用一样：打开、读、关闭。TCP通过IP来间接调用本地网络接口，TCP接口提供了发送（或接收）数据报给任何互联网中TCP地址的调用。&lt;/p&gt;
&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;优先级与安全性&lt;/font&gt; 

&lt;p&gt;使用TCP的用户可能会指定优先级和安全性。当这些特性未被使用时，应提供默认值。&lt;/p&gt;
&lt;font size=&quot;5&quot; color=&quot;#FF2D2D&quot;&gt;操作&lt;/font&gt; 

&lt;p&gt;TCP允许的操作包括以下几个方面：&lt;/p&gt;
&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;基本数据传输&lt;/font&gt; 

&lt;p&gt;TCP能够在两个方向上传输连续的字节流，通常会把一些字节打包成片段，然后交给互联网系统进行传输。&lt;/p&gt;
&lt;p&gt;通常TCP可以根据自己的方便，进行阻塞和转发。因此需要提供&lt;code&gt;PUSH&lt;/code&gt;操作，以免用户需要立即发送。该操作会导致TCP立即转发数据，但这个过程对接收方应是不可见的。&lt;/p&gt;
&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;可靠性&lt;/font&gt; 

&lt;p&gt;TCP能够从传输错误中恢复，除非互联网完全断开。传输错误包括：损坏、丢失、重复、乱序。&lt;/p&gt;
&lt;p&gt;为了实现这个目的，每个传输的字节都被标记一个序列号（SEQ)，同时接收方应提供确认号（ACK）。如果确认号超时，则重发数据。在接受端，序列号用来重新排列乱序或重复的片段。数据损坏用一个校验值来处理，在接收端抛弃损坏的片段。&lt;/p&gt;
&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;流控制&lt;/font&gt; 

&lt;p&gt;TCP提供了一种手段来管理发送者发送的数据量。接收者发送一个“窗口”（接下来期望接受的字节范围）给发送者，发送者在接收到进一步允许前只能发送这些字节。&lt;/p&gt;
&lt;font size=&quot;4&quot; color=&quot;#FF2D2D&quot;&gt;多路复用&lt;/font&gt; 

&lt;p&gt;为了允许同一主机的不同进程同时使用TCP设施，TCP提供了一组端口，加上互联网通信层地址（IP），组成一个socket。一对socket唯一地标识了一个TCP连接。&lt;br&gt;而一个进程可以绑定到端口来监听网络。为了方便，将常用进程绑定到公开的确定端口。这样就可以通过公共地址来访问服务了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于其他非公开确定的端口，建立连接涉及到更多的动态机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font size=&quot;5&quot; color=&quot;#FF2D2D&quot;&gt;TCP头&lt;/font&gt; 

&lt;p&gt;在传送的片段中，TCP头的位置紧接着IP头，其中提供了TCP协议规定的必要信息：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; 0                   1                   2                   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|          Source Port          |       Destination Port        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                        Sequence Number                        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                    Acknowledgment Number                      |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  Data |           |U|A|P|R|S|F|                               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| Offset| Reserved  |R|C|S|S|Y|I|            Window             |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|       |           |G|K|H|T|N|N|                               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|           Checksum            |         Urgent Pointer        |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                    Options                    |    Padding    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                             data                              |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;字段说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Source/Destination Port&lt;/code&gt;：源与目标端口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sequence Number&lt;/code&gt;：该片段中第一个数据字节的序列号。如果&lt;code&gt;SYN&lt;/code&gt;是1，则该序列号成为初始序列号（&lt;code&gt;ISN&lt;/code&gt;），第一个数据字节为&lt;code&gt;ISN+1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Acknowledgment Number&lt;/code&gt;：如果&lt;code&gt;ACK&lt;/code&gt;是1，该字段包含期望收到的下一个序列号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data Offset&lt;/code&gt;：TCP头的长度，也就是数据的起始位置。单位为32位字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Reserved&lt;/code&gt;：保留字段，必须为0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Conrol Bits&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;URG&lt;/code&gt;：&lt;code&gt;Urgent Pointer&lt;/code&gt;字段起作用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ACK&lt;/code&gt;：&lt;code&gt;Acknowledgment&lt;/code&gt;字段起作用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PSH&lt;/code&gt;：&lt;code&gt;PUSH&lt;/code&gt;功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RST&lt;/code&gt;：重置连接。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYN&lt;/code&gt;：同步序列号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIN&lt;/code&gt;：别再发送了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Window&lt;/code&gt;：期望接收的字节长度，从&lt;code&gt;Acknowledgment&lt;/code&gt;开始。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Checksum&lt;/code&gt;：头和数据中所有16位字的反码和的反码。如果是奇数字节，最后字节后补零。计算该字段时，该字段值为0。该校验和还包含了伪头部，它包含IP地址，用来防止路由错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Urgent Pointer&lt;/code&gt;：当前紧急数据的开始位置，从序列号算起。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Options&lt;/code&gt;：该字段位于TCP头的末尾，可以有多个整字节。可以包括选项类型、选项长度、选项数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Padding&lt;/code&gt;：值为0的补白，确保TCP头长度为32位的整数倍。&lt;/li&gt;
&lt;/ol&gt;
&lt;font size=&quot;5&quot; color=&quot;#FF2D2D&quot;&gt;TCP状态&lt;/font&gt; 

&lt;p&gt;一个TCP连接在整个生命周期内可能处在不同的状态，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;LISTEN&lt;/code&gt;：等待任何远程TCP的连接请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYN-SENT&lt;/code&gt;：发送连接请求后，等待匹配连接请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYN-RECEIVED&lt;/code&gt;：收到并发送一个连接请求后，等待连接请求确认。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ESTABLISHED&lt;/code&gt;：一个打开的连接，收到的数据可以递交给用户，正常的数据传输状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIN-WAIT-1&lt;/code&gt;：等待远程TCP的终止请求，或等待终止请求的确认。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIN-WAIT-2&lt;/code&gt;：等待远程TCP的终止请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CLOSE-WAIT&lt;/code&gt;：等待本地用户的连接终止请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CLOSING&lt;/code&gt;：等待远程TCP的终止请求确认。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LAST-ACK&lt;/code&gt;：等待远程TCP终止请求的确认，之前发送的终止请求包含终止请求的确认。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIME-WAIT&lt;/code&gt;：等待足够的时间，确保远程TCP收到了终止请求的确认。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CLOSED&lt;/code&gt;：没有任何连接状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;font size=&quot;5&quot; color=&quot;#FF2D2D&quot;&gt;建立连接&lt;/font&gt; 

&lt;p&gt;使用&lt;code&gt;OPEN&lt;/code&gt;调用来声明一个连接，同时提供本地端口、远程socket参数、以及被动等待还是主动连接。此时TCP会提供一个名称（关联着传输控制块，TCB，来存储该连接的变量的数据结构）用于后续调用。两个进程如果同时发起主动连接，它们也会正确地建立连接。这种灵活性在分布式系统中至关重要。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本地被动连接可以指定远程socket，也可以不指定。后者将会接受所有的远程socket。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建立连接采用三步握手过程，一般是一方初始化请求，另一方响应该请求。以下是一个简单的建立连接过程：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    TCP A                                                TCP B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  CLOSED                                               LISTEN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  SYN-SENT    --&amp;gt; &amp;lt;SEQ=100&amp;gt;&amp;lt;CTL=SYN&amp;gt;               --&amp;gt; SYN-RECEIVED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  ESTABLISHED &amp;lt;-- &amp;lt;SEQ=300&amp;gt;&amp;lt;ACK=101&amp;gt;&amp;lt;CTL=SYN,ACK&amp;gt;  &amp;lt;-- SYN-RECEIVED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.  ESTABLISHED --&amp;gt; &amp;lt;SEQ=101&amp;gt;&amp;lt;ACK=301&amp;gt;&amp;lt;CTL=ACK&amp;gt;       --&amp;gt; ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.  ESTABLISHED --&amp;gt; &amp;lt;SEQ=101&amp;gt;&amp;lt;ACK=301&amp;gt;&amp;lt;CTL=ACK&amp;gt;&amp;lt;DATA&amp;gt; --&amp;gt; ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意第5行，此时发送了一些数据，而&lt;code&gt;SEQ&lt;/code&gt;值没有变，因为&lt;code&gt;ACK&lt;/code&gt;报文不占用序列号空间（不同于数据和&lt;code&gt;SYN&lt;/code&gt;）。否则我们将需要确认&lt;code&gt;ACK&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于同时发起连接，将会稍微复杂一些：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    TCP A                                            TCP B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  CLOSED                                           CLOSED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  SYN-SENT     --&amp;gt; &amp;lt;SEQ=100&amp;gt;&amp;lt;CTL=SYN&amp;gt;              ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  SYN-RECEIVED &amp;lt;-- &amp;lt;SEQ=300&amp;gt;&amp;lt;CTL=SYN&amp;gt;              &amp;lt;-- SYN-SENT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.               ... &amp;lt;SEQ=100&amp;gt;&amp;lt;CTL=SYN&amp;gt;              --&amp;gt; SYN-RECEIVED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.  SYN-RECEIVED --&amp;gt; &amp;lt;SEQ=100&amp;gt;&amp;lt;ACK=301&amp;gt;&amp;lt;CTL=SYN,ACK&amp;gt; ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.  ESTABLISHED  &amp;lt;-- &amp;lt;SEQ=300&amp;gt;&amp;lt;ACK=101&amp;gt;&amp;lt;CTL=SYN,ACK&amp;gt; &amp;lt;-- SYN-RECEIVED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7.               ... &amp;lt;SEQ=101&amp;gt;&amp;lt;ACK=301&amp;gt;&amp;lt;CTL=ACK&amp;gt;     --&amp;gt; ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;三路握手过程可以从旧的重复&lt;code&gt;SYN&lt;/code&gt;中恢复，要用到&lt;code&gt;RST&lt;/code&gt;字段：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    TCP A                                                TCP B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  CLOSED                                               LISTEN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  SYN-SENT    --&amp;gt; &amp;lt;SEQ=100&amp;gt;&amp;lt;CTL=SYN&amp;gt;               ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  (duplicate) ... &amp;lt;SEQ=90&amp;gt;&amp;lt;CTL=SYN&amp;gt;               --&amp;gt; SYN-RECEIVED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.  SYN-SENT    &amp;lt;-- &amp;lt;SEQ=300&amp;gt;&amp;lt;ACK=91&amp;gt;&amp;lt;CTL=SYN,ACK&amp;gt;  &amp;lt;-- SYN-RECEIVED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.  SYN-SENT    --&amp;gt; &amp;lt;SEQ=91&amp;gt;&amp;lt;CTL=RST&amp;gt;               --&amp;gt; LISTEN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.              ... &amp;lt;SEQ=100&amp;gt;&amp;lt;CTL=SYN&amp;gt;               --&amp;gt; SYN-RECEIVED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7.  SYN-SENT    &amp;lt;-- &amp;lt;SEQ=400&amp;gt;&amp;lt;ACK=101&amp;gt;&amp;lt;CTL=SYN,ACK&amp;gt;  &amp;lt;-- SYN-RECEIVED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8.  ESTABLISHED --&amp;gt; &amp;lt;SEQ=101&amp;gt;&amp;lt;ACK=401&amp;gt;&amp;lt;CTL=ACK&amp;gt;      --&amp;gt; ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，第3行是旧的重复&lt;code&gt;SYN&lt;/code&gt;，接收方在不知情的情况下仍然确认了该&lt;code&gt;SYN&lt;/code&gt;。此时，发送方应重置该&lt;code&gt;SYN&lt;/code&gt;（地5行）。然后继续新的连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外一种情况是一方因故关闭，造成半开的连接。TCP的策略是发现这种情况并关闭该连接后重新由关闭方发起连接。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    TCP A                                           TCP B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  (CRASH)                               (send 300,receive 100)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  CLOSED                                           ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  SYN-SENT --&amp;gt; &amp;lt;SEQ=400&amp;gt;&amp;lt;CTL=SYN&amp;gt;              --&amp;gt; (??)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.  (!!)     &amp;lt;-- &amp;lt;SEQ=300&amp;gt;&amp;lt;ACK=100&amp;gt;&amp;lt;CTL=ACK&amp;gt;     &amp;lt;-- ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.  SYN-SENT --&amp;gt; &amp;lt;SEQ=100&amp;gt;&amp;lt;CTL=RST&amp;gt;              --&amp;gt; (Abort!!)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.  SYN-SENT                                         CLOSED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7.  SYN-SENT --&amp;gt; &amp;lt;SEQ=400&amp;gt;&amp;lt;CTL=SYN&amp;gt;              --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，接收到&lt;code&gt;RST&lt;/code&gt;后首先进行验证（&lt;code&gt;RST&lt;/code&gt;的&lt;code&gt;SEQ&lt;/code&gt;必须在窗口内），然后进行重置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;font size=&quot;5&quot; color=&quot;#FF2D2D&quot;&gt;关闭连接&lt;/font&gt; 

&lt;p&gt;TCP是全双工的，&lt;code&gt;CLOSE&lt;/code&gt;操作却是单工的方式：&lt;code&gt;CLOSE&lt;/code&gt;之后不再发送数据，但仍然可以继续接收数据直到远程TCP关闭。即&lt;code&gt;CLOSE&lt;/code&gt;意味着：我没有要发送的数据了。&lt;/p&gt;
&lt;p&gt;对于一方首先关闭连接的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    TCP A                                                TCP B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  ESTABLISHED                                          ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  (Close)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    FIN-WAIT-1  --&amp;gt; &amp;lt;SEQ=100&amp;gt;&amp;lt;ACK=300&amp;gt;&amp;lt;CTL=FIN,ACK&amp;gt;  --&amp;gt; CLOSE-WAIT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  FIN-WAIT-2  &amp;lt;-- &amp;lt;SEQ=300&amp;gt;&amp;lt;ACK=101&amp;gt;&amp;lt;CTL=ACK&amp;gt;      &amp;lt;-- CLOSE-WAIT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.                                                       (Close)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TIME-WAIT   &amp;lt;-- &amp;lt;SEQ=300&amp;gt;&amp;lt;ACK=101&amp;gt;&amp;lt;CTL=FIN,ACK&amp;gt;  &amp;lt;-- LAST-ACK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.  TIME-WAIT   --&amp;gt; &amp;lt;SEQ=101&amp;gt;&amp;lt;ACK=301&amp;gt;&amp;lt;CTL=ACK&amp;gt;      --&amp;gt; CLOSED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.  (2 MSL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CLOSED&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于双方同时关闭连接的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    TCP A                                                TCP B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  ESTABLISHED                                          ESTABLISHED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  (Close)                                              (Close)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    FIN-WAIT-1  --&amp;gt; &amp;lt;SEQ=100&amp;gt;&amp;lt;ACK=300&amp;gt;&amp;lt;CTL=FIN,ACK&amp;gt;  ... FIN-WAIT-1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;lt;-- &amp;lt;SEQ=300&amp;gt;&amp;lt;ACK=100&amp;gt;&amp;lt;CTL=FIN,ACK&amp;gt;  &amp;lt;--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ... &amp;lt;SEQ=100&amp;gt;&amp;lt;ACK=300&amp;gt;&amp;lt;CTL=FIN,ACK&amp;gt;  --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  CLOSING     --&amp;gt; &amp;lt;SEQ=101&amp;gt;&amp;lt;ACK=301&amp;gt;&amp;lt;CTL=ACK&amp;gt;      ... CLOSING&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;lt;-- &amp;lt;SEQ=301&amp;gt;&amp;lt;ACK=101&amp;gt;&amp;lt;CTL=ACK&amp;gt;      &amp;lt;--&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ... &amp;lt;SEQ=101&amp;gt;&amp;lt;ACK=301&amp;gt;&amp;lt;CTL=ACK&amp;gt;      --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.  TIME-WAIT                                            TIME-WAIT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (2 MSL)                                              (2 MSL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CLOSED                                               CLOSED&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MSL&lt;/strong&gt;: Maximum Segment Lifetime, the time a TCP segment can exist in the internetwork system.  Arbitrarily defined to be 2 minutes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://tools.ietf.org/html/rfc793&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC-793&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;&lt;br&gt;    &lt;p&gt;&lt;img src=&quot;http://7xrzzi.com1.z0.glb.clouddn.com/yunvooliyunvooli_meitu_1.jpg&quot; align=&quot;center&quot;&gt;&lt;/p&gt;&lt;br&gt;&lt;/center&gt;



</content>
    
    <summary type="html">
    
      &lt;p&gt;TCP被作为一种运行在分组交换网络（以及它们的互联系统）上的高可靠的主机到主机协议。TCP是面向连接的、端到端的通用协议，却对下层协议的假设甚少（可以是多网络环境，只要求一个不可靠的报文服务），一般用于互联网上不同主机的进程间通信。&lt;br&gt;现行协议版本被IETF标准化为&lt;a
    
    </summary>
    
    
      <category term="TCP，协议" scheme="http://yunvoo.com/tags/TCP%EF%BC%8C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Item 7：将多态基类的析构函数声明为虚函数</title>
    <link href="http://yunvoo.com//blog/2015/07/24/effective-cpp-7.html"/>
    <id>http://yunvoo.com//blog/2015/07/24/effective-cpp-7.html</id>
    <published>2015-07-23T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.362Z</updated>
    
    <content type="html">&lt;h1 id=&quot;虚析构函数&quot;&gt;&lt;a href=&quot;#虚析构函数&quot; class=&quot;headerlink&quot; title=&quot;虚析构函数&quot;&gt;&lt;/a&gt;虚析构函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Item 7: Declare destructors virtual in polymorphic base classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;析构函数声明为虚函数恐怕是面试中最常见的问题之一。目的在于以基类指针调用析构函数时能够正确地析构子类部分的内存。&lt;br&gt;否则子类部分的内存将会泄漏，正确的用法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 基类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; TimeKeeper&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; ~TimeKeeper();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TimeKeeper *ptk = getTimeKeeper():  &lt;span class=&quot;comment&quot;&gt;// 可能返回任何一种子类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; ptk;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值得一提的是虚函数表指针的内存占用问题，我们知道所有存在虚方法的对象中都会存有一个虚函数表指针&lt;code&gt;vptr&lt;/code&gt;，&lt;br&gt;用来在运行时定位虚函数。同时，每个存在虚方法的类也会对应一个虚函数列表的指针&lt;code&gt;vtbl&lt;/code&gt;。&lt;br&gt;函数调用时会在&lt;code&gt;vtbl&lt;/code&gt;指向的虚函数表中寻找&lt;code&gt;vptr&lt;/code&gt;指向的那个函数。&lt;/p&gt;
&lt;p&gt;为了准确地描述&lt;code&gt;vptr&lt;/code&gt;的大小，先来了解一下对象的&lt;code&gt;sizeof&lt;/code&gt;计算方式，以及字节对齐问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器：gcc version 5.1.0，目标平台：x86_64-apple-darwin14.3.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;空对象大小为1&quot;&gt;&lt;a href=&quot;#空对象大小为1&quot; class=&quot;headerlink&quot; title=&quot;空对象大小为1&quot;&gt;&lt;/a&gt;空对象大小为1&lt;/h1&gt;&lt;p&gt;没有任何成员的对象也需要有地址，否则怎么定位它呢？所以编译器会给它一字节的大小：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C0&amp;#123;&amp;#125;;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(C0);     &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C1&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; i;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(C1);     &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只有一个&lt;code&gt;char&lt;/code&gt;成员的对象大小也是1&lt;/p&gt;
&lt;h1 id=&quot;字节对齐&quot;&gt;&lt;a href=&quot;#字节对齐&quot; class=&quot;headerlink&quot; title=&quot;字节对齐&quot;&gt;&lt;/a&gt;字节对齐&lt;/h1&gt;&lt;p&gt;说道对象大小，来总结一下字节对齐的问题吧，也是笔试面试的常见题型。字节对齐有三个准则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结构体变量的首地址能够被其最宽基本类型成员的大小所整除；&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；&lt;/li&gt;
&lt;li&gt;结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C2&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; i, j;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(C2);     &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C3&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; i, j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(C3);     &lt;span class=&quot;comment&quot;&gt;// 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为&lt;code&gt;int&lt;/code&gt;大小是4，两个&lt;code&gt;char&lt;/code&gt;大小是2，故总的大小以4为基对齐，大小为4*2 = 8。&lt;br&gt;另外可以通过编译指令&lt;code&gt;#pragma pack(N)&lt;/code&gt;指定N字节对齐，此时每个数据项将会按照&lt;code&gt;min(N, sizeof(TYPE))&lt;/code&gt;进行对齐。&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;pragma&lt;/span&gt; pack (2) &lt;span class=&quot;comment&quot;&gt;/*指定按2字节对齐*/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;pragma&lt;/span&gt; pack ()   &lt;span class=&quot;comment&quot;&gt;/*取消指定对齐，恢复缺省对齐*/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述例子来自： &lt;a href=&quot;http://www.linuxsong.org/2010/09/c-byte-alignment/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.linuxsong.org/2010/09/c-byte-alignment/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;虚函数表指针&quot;&gt;&lt;a href=&quot;#虚函数表指针&quot; class=&quot;headerlink&quot; title=&quot;虚函数表指针&quot;&gt;&lt;/a&gt;虚函数表指针&lt;/h1&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C4&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(C4);     &lt;span class=&quot;comment&quot;&gt;// 16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为我的Target是64位平台，故&lt;code&gt;vptr&lt;/code&gt;的大小为8，&lt;code&gt;char&lt;/code&gt;大小为1，故总的大小以8为基对齐，大小为8*2 = 16。&lt;br&gt;虚函数指针不仅使得对象更加占用内存空间，同时会造成可移植性问题。&lt;br&gt;问题很明显：一个包含&lt;code&gt;vptr&lt;/code&gt;的C++对象传递给Fortran时，由于Fortran中没有&lt;code&gt;vptr&lt;/code&gt;的概念，&lt;br&gt;因此需要重新计算对象大小，然而&lt;code&gt;vptr&lt;/code&gt;的大小是平台相关的。。。&lt;/p&gt;
&lt;h1 id=&quot;封闭类&quot;&gt;&lt;a href=&quot;#封闭类&quot; class=&quot;headerlink&quot; title=&quot;封闭类&quot;&gt;&lt;/a&gt;封闭类&lt;/h1&gt;&lt;p&gt;包含对象成员的类称为封闭类，封闭类以对象成员中最大的基本数据类型的长度进行字节对齐。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C5&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    C4 c4;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(C5);     &lt;span class=&quot;comment&quot;&gt;// 24&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;C4和C5中最大的基本数据类型是&lt;code&gt;void*&lt;/code&gt;（&lt;code&gt;vptr&lt;/code&gt;的类型），其大小为8，故以8为基对齐的结果是8*3 = 24。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;虚析构函数&quot;&gt;&lt;a href=&quot;#虚析构函数&quot; class=&quot;headerlink&quot; title=&quot;虚析构函数&quot;&gt;&lt;/a&gt;虚析构函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Item 7: Declare destructors virtual in polymorphic base classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;析构函数声明为虚函数恐怕是面试中最常见的问题之一。目的在于以基类指针调用析构函数时能够正确地析构子类部分的内存。&lt;br&gt;否则子类部分的内存将会泄漏，正确的用法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 基类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; TimeKeeper&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; ~TimeKeeper();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TimeKeeper *ptk = getTimeKeeper():  &lt;span class=&quot;comment&quot;&gt;// 可能返回任何一种子类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; ptk;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值得一提的是虚函数表指针的内存占用问题，我们知道所有存在虚方法的对象中都会存有一个虚函数表指针&lt;code&gt;vptr&lt;/code&gt;，&lt;br&gt;用来在运行时定位虚函数。同时，每个存在虚方法的类也会对应一个虚函数列表的指针&lt;code&gt;vtbl&lt;/code&gt;。&lt;br&gt;函数调用时会在&lt;code&gt;vtbl&lt;/code&gt;指向的虚函数表中寻找&lt;code&gt;vptr&lt;/code&gt;指向的那个函数。&lt;/p&gt;
&lt;p&gt;为了准确地描述&lt;code&gt;vptr&lt;/code&gt;的大小，先来了解一下对象的&lt;code&gt;sizeof&lt;/code&gt;计算方式，以及字节对齐问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器：gcc version 5.1.0，目标平台：x86_64-apple-darwin14.3.0&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++ 内存 多态 指针 编译 虚函数 字节对齐 析构函数" scheme="http://yunvoo.com/tags/C-%E5%86%85%E5%AD%98-%E5%A4%9A%E6%80%81-%E6%8C%87%E9%92%88-%E7%BC%96%E8%AF%91-%E8%99%9A%E5%87%BD%E6%95%B0-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Item 6：禁用那些不需要的缺省方法</title>
    <link href="http://yunvoo.com//blog/2015/07/23/effective-cpp-6.html"/>
    <id>http://yunvoo.com//blog/2015/07/23/effective-cpp-6.html</id>
    <published>2015-07-22T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.374Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Item 6: Explicitly disallow the use of compiler-generated functions you do not want.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在C++中，编译器会自动生成一些你没有显式定义的函数，它们包括：构造函数、析构函数、复制构造函数、&lt;code&gt;=&lt;/code&gt;运算符。&lt;br&gt;关于这些函数是的调用时机可以参考：&lt;a href=&quot;/2015/07/23/effective-cpp-5&quot;&gt;那些被C++默默地声明和调用的函数&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这些默认生成的函数给我们的类提供了缺省的功能，比如赋值、复制、构造、析构等；&lt;br&gt;同时也给我我们重载这些函数的机会，借此实现更加复杂的对象行为。&lt;/p&gt;
&lt;p&gt;然而有时候我们希望禁用掉这些函数。比如对于一个单例而言，我们不希望它能够被直接构造，或者拷贝。&lt;br&gt;我们通过把自动生成的函数设为&lt;code&gt;private&lt;/code&gt;来禁用它，&lt;br&gt;&lt;a href=&quot;/2015/07/22/effective-cpp-4.html&quot;&gt;Effective C++笔记：确保变量的初始化&lt;/a&gt;&lt;br&gt;提到的单例是一个例子。这里我们来实现一个不可拷贝的类&lt;code&gt;Uncopyable&lt;/code&gt;，&lt;br&gt;需要声明其复制构造函数与&lt;code&gt;=&lt;/code&gt;运算符为&lt;code&gt;private&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Uncopyable&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Uncopyable(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Uncopyable&amp;amp;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Uncopyable&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Uncopyable&amp;amp;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Uncopyable()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值得一提的是，&lt;code&gt;Uncopyable&lt;/code&gt;的不可拷贝特性是可以继承的。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Homeforsale: &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Uncopyable&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;这里改为&lt;code&gt;public&lt;/code&gt;继承仍然可行，但语义上不正确，&lt;code&gt;Uncopyable&lt;/code&gt;更像是一种实现方式或者接口，而不是一个基类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在编译器默认生成的拷贝构造函数和赋值运算符中，会调用父类的相应函数。&lt;br&gt;然而这些调用将会被拒绝，因为对父类这些函数的访问将被拒绝。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Item 6: Explicitly disallow the use of compiler-generated functions you do not want.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在C++中，编译器会自动生成一些你没
    
    </summary>
    
    
      <category term="C++ 继承 运算符 构造函数 析构函数 赋值运算符 运算符重载 拷贝构造函数" scheme="http://yunvoo.com/tags/C-%E7%BB%A7%E6%89%BF-%E8%BF%90%E7%AE%97%E7%AC%A6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Item 5：那些被C++默默地声明和调用的函数</title>
    <link href="http://yunvoo.com//blog/2015/07/23/effective-cpp-5.html"/>
    <id>http://yunvoo.com//blog/2015/07/23/effective-cpp-5.html</id>
    <published>2015-07-22T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.386Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Item 5:  Know what functions C++ silently writes and calls&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在C++中，编译器会自动生成一些你没有显式定义的函数，它们包括：构造函数、析构函数、复制构造函数、&lt;code&gt;=&lt;/code&gt;运算符。&lt;br&gt;有时为了符合既有设计，我们不希望自动生成这些函数，我们可以把它们显式声明为&lt;code&gt;private&lt;/code&gt;。&lt;br&gt;此时在使用这些类的客户看来，它们就像不存在一样。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Empty&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 默认构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Empty()&amp;#123;&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Empty(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Empty&amp;amp; rhs)&amp;#123;&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 析构函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~Empty()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 赋值运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Empty&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Empty&amp;amp; rhs)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些编译器自动生成的缺省方法是可以禁用的，把它们声明为&lt;code&gt;private&lt;/code&gt;便能解决绝大多数问题。&lt;br&gt;关于禁用这些方法的更多讨论：&lt;a href=&quot;/2015/07/23/effective-cpp-6.html&quot;&gt;Effective C++: Item 6&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;调用时机&quot;&gt;&lt;a href=&quot;#调用时机&quot; class=&quot;headerlink&quot; title=&quot;调用时机&quot;&gt;&lt;/a&gt;调用时机&lt;/h1&gt;&lt;p&gt;当我们没有显式地定义上述这四种函数时，编译器会自动帮我们定义。这些函数它们调用的时机如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造函数：对象定义；使用其他兼容的类型初始化对象时（可使用 &lt;code&gt;explicit&lt;/code&gt; 来避免这种情况）&lt;/li&gt;
&lt;li&gt;复制构造函数：用一个对象来初始化另一对象时；传入对象参数时；返回对象时；&lt;/li&gt;
&lt;li&gt;析构函数：作用域结束（包括函数返回）时；&lt;code&gt;delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;运算符：一个对象赋值给另一对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了更清晰地说明它们的调用时机，来个例子吧：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Empty e1;               &lt;span class=&quot;comment&quot;&gt;// 默认构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Empty &lt;span class=&quot;title&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(e1)&lt;/span&gt;&lt;/span&gt;;           &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Empty e3 = e1;          &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e2 = e1;                &lt;span class=&quot;comment&quot;&gt;// = 运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Empty e)&lt;/span&gt;&lt;/span&gt;&amp;#123;     &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数，拷贝一份参数对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e;           &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数，拷贝一份返回对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;// 析构函数，拷贝得到的参数对象被析构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e2 = func(e1);          &lt;span class=&quot;comment&quot;&gt;// = 运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;// 析构函数，返回值被析构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;引用成员&quot;&gt;&lt;a href=&quot;#引用成员&quot; class=&quot;headerlink&quot; title=&quot;引用成员&quot;&gt;&lt;/a&gt;引用成员&lt;/h1&gt;&lt;p&gt;当对象包含引用成员时，拷贝和赋值行为将会变得非常有趣，考虑这样一个类：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    string &amp;amp; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person(string&amp;amp; str): name(str)&amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string s1 = &quot;alice&quot;, s2 = &quot;bob&quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person p1(s1), p2(s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p1 = p2;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;赋值后，&lt;code&gt;p1.name&lt;/code&gt;会指向&lt;code&gt;p2.name&lt;/code&gt;吗？我们知道在C++中引用本身是不可修改的。&lt;br&gt;即使&lt;code&gt;p1.name&lt;/code&gt;指向了&lt;code&gt;p2.name&lt;/code&gt;，那么对&lt;code&gt;p1.name&lt;/code&gt;的赋值将会影响到&lt;code&gt;p2&lt;/code&gt;？&lt;br&gt;于是，C++拒绝编译上述代码，此时我们需要手动定义一个赋值运算符。&lt;br&gt;（更直观的理解参见blueyi的评论）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说来神奇，拷贝构造函数也面临同样的情况，但拷贝构造函数却不需要自定义便能编译，并且两个引用指向同一对象。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Item 5:  Know what functions C++ silently writes and calls&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在C++中，编译器会自动生成一些你没有显式定义的函数，它们包括：构造函数、析构函数、复制构造函数、&lt;code&gt;=&lt;/code&gt;运算符。&lt;br&gt;有时为了符合既有设计，我们不希望自动生成这些函数，我们可以把它们显式声明为&lt;code&gt;private&lt;/code&gt;。&lt;br&gt;此时在使用这些类的客户看来，它们就像不存在一样。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Empty&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 默认构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Empty()&amp;#123;&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Empty(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Empty&amp;amp; rhs)&amp;#123;&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 析构函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~Empty()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 赋值运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Empty&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Empty&amp;amp; rhs)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些编译器自动生成的缺省方法是可以禁用的，把它们声明为&lt;code&gt;private&lt;/code&gt;便能解决绝大多数问题。&lt;br&gt;关于禁用这些方法的更多讨论：&lt;a href=&quot;/2015/07/23/effective-cpp-6.html&quot;&gt;Effective C++: Item 6&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;调用时机&quot;&gt;&lt;a href=&quot;#调用时机&quot; class=&quot;headerlink&quot; title=&quot;调用时机&quot;&gt;&lt;/a&gt;调用时机&lt;/h1&gt;&lt;p&gt;当我们没有显式地定义上述这四种函数时，编译器会自动帮我们定义。这些函数它们调用的时机如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造函数：对象定义；使用其他兼容的类型初始化对象时（可使用 &lt;code&gt;explicit&lt;/code&gt; 来避免这种情况）&lt;/li&gt;
&lt;li&gt;复制构造函数：用一个对象来初始化另一对象时；传入对象参数时；返回对象时；&lt;/li&gt;
&lt;li&gt;析构函数：作用域结束（包括函数返回）时；&lt;code&gt;delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;运算符：一个对象赋值给另一对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了更清晰地说明它们的调用时机，来个例子吧：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Empty e1;               &lt;span class=&quot;comment&quot;&gt;// 默认构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Empty &lt;span class=&quot;title&quot;&gt;e2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(e1)&lt;/span&gt;&lt;/span&gt;;           &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Empty e3 = e1;          &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e2 = e1;                &lt;span class=&quot;comment&quot;&gt;// = 运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Empty e)&lt;/span&gt;&lt;/span&gt;&amp;#123;     &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数，拷贝一份参数对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e;           &lt;span class=&quot;comment&quot;&gt;// 拷贝构造函数，拷贝一份返回对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;// 析构函数，拷贝得到的参数对象被析构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e2 = func(e1);          &lt;span class=&quot;comment&quot;&gt;// = 运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;comment&quot;&gt;// 析构函数，返回值被析构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C++ 引用 编译 运算符 构造函数 析构函数 赋值运算符 拷贝构造函数" scheme="http://yunvoo.com/tags/C-%E5%BC%95%E7%94%A8-%E7%BC%96%E8%AF%91-%E8%BF%90%E7%AE%97%E7%AC%A6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>进程的地址空间：TEXT，DATA，BSS，HEAP，STACK</title>
    <link href="http://yunvoo.com//blog/2015/07/22/memory-segment.html"/>
    <id>http://yunvoo.com//blog/2015/07/22/memory-segment.html</id>
    <published>2015-07-21T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.398Z</updated>
    
    <content type="html">&lt;p&gt;现代操作系统对每个进程都分配了完整的虚拟内存地址空间。进程会把整个地址空间分成多个区间来使用。&lt;br&gt;程序员最为熟悉的两个区间莫过于&lt;strong&gt;堆&lt;/strong&gt;和&lt;strong&gt;栈&lt;/strong&gt;。然而还有其他的内存区间来存储代码、静态、全局变量等等。&lt;br&gt;本文来总结一下这些内存区间到底存的是哪些东西。先看图：&lt;/p&gt;
&lt;div class=&quot;float: left; max-width: 350px;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;/assets/img/blog/memory.png&quot; alt=&quot;@2x&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;small&gt;图片来源：&lt;br&gt;  &lt;a href=&quot;http://www.sw-at.com/blog/2011/03/23/where-does-code-execute-process-address-space-code-gvar-bss-heap-stack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SWAT Blog&lt;/a&gt;&lt;br&gt;&lt;/small&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;虚拟内存技术使得每个进程都可以独占整个内存空间，地址从零开始，直到内存上限。&lt;br&gt;每个进程都将这部分空间（从低地址到高地址）分为六个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TEXT段：整个程序的代码，以及所有的常量。这部分内存是是固定大小的，只读的。&lt;/li&gt;
&lt;li&gt;DATA段，又称GVAR：初始化为非零值的全局变量。&lt;/li&gt;
&lt;li&gt;BSS段：初始化为0或未初始化的全局变量和静态变量。&lt;/li&gt;
&lt;li&gt;HEAP（堆空间）：动态内存区域，使用&lt;code&gt;malloc&lt;/code&gt;或&lt;code&gt;new&lt;/code&gt;申请的内存。&lt;/li&gt;
&lt;li&gt;未使用的内存。&lt;/li&gt;
&lt;li&gt;STACK（栈空间）：局部变量、参数、返回值都存在这里，函数调用开始会参数入栈、局部变量入栈；调用结束依次出栈。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中堆空间和栈空间的大小是可变的，堆空间从下往上生长，栈空间从上往下生长。&lt;/p&gt;
&lt;p&gt;由于常量存储在TEXT段中，所有对常量的赋值都将产生&lt;code&gt;segment fault&lt;/code&gt;异常。&lt;/p&gt;
&lt;p&gt;可以认为BSS段中的所有字节都是0。因为未初始化的全局变量、静态变量都在BSS段中，&lt;br&gt;所以它们都会被初始化为0，同时类的成员变量也会被初始化为0，但编译器不保证局部变量的初始化。&lt;/p&gt;
&lt;p&gt;上面说栈（STACK）是从上到下（高地址到低地址）分配的，而且我们知道，&lt;br&gt;函数的局部变量的空间是在进入函数体后才分配的，在栈空间里。来个例子来看看吧！&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, b=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&amp;amp;b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *p = &lt;span class=&quot;number&quot;&gt;258&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;, a, b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出是&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;属于局部变量，存储在栈空间中，先分配&lt;code&gt;a&lt;/code&gt;的地址，再分配&lt;code&gt;b&lt;/code&gt;的地址。因为栈是从上往下生长的，所以&lt;code&gt;b&lt;/code&gt;的地址比&lt;code&gt;a&lt;/code&gt;低一个字节。&lt;br&gt;然后对&lt;code&gt;b&lt;/code&gt;的地址进行赋值258（&lt;code&gt;int&lt;/code&gt;是4字节，十六进制表示是&lt;code&gt;0x00 00 01 02&lt;/code&gt;）。最后1字节&lt;code&gt;0x02&lt;/code&gt;赋值给了&lt;code&gt;b&lt;/code&gt;，接下来1字节&lt;code&gt;0x01&lt;/code&gt;赋值给了&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上述结果和CPU端模式也有关系！我的CPU是小端字节序的~ 低位存的是低字节。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;现代操作系统对每个进程都分配了完整的虚拟内存地址空间。进程会把整个地址空间分成多个区间来使用。&lt;br&gt;程序员最为熟悉的两个区间莫过于&lt;strong&gt;堆&lt;/strong&gt;和&lt;strong&gt;栈&lt;/strong&gt;。然而还有其他的内存区间来存储代码、静态、全局变量等等。&lt;br&gt;本文来总结一下这些内存区间到底存的是哪些东西。先看图：&lt;/p&gt;
&lt;div class=&quot;float: left; max-width: 350px;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;/assets/img/blog/memory.png&quot; alt=&quot;@2x&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;small&gt;图片来源：&lt;br&gt;  &lt;a href=&quot;http://www.sw-at.com/blog/2011/03/23/where-does-code-execute-process-address-space-code-gvar-bss-heap-stack/&quot;&gt;SWAT Blog&lt;/a&gt;&lt;br&gt;&lt;/small&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="C++ 栈空间 堆空间 内存 常量 编译 进程 字节序 全局变量 动态内存 操作系统 虚拟内存 静态变量" scheme="http://yunvoo.com/tags/C-%E6%A0%88%E7%A9%BA%E9%97%B4-%E5%A0%86%E7%A9%BA%E9%97%B4-%E5%86%85%E5%AD%98-%E5%B8%B8%E9%87%8F-%E7%BC%96%E8%AF%91-%E8%BF%9B%E7%A8%8B-%E5%AD%97%E8%8A%82%E5%BA%8F-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Item 4：确保变量的初始化</title>
    <link href="http://yunvoo.com//blog/2015/07/22/effective-cpp-4.html"/>
    <id>http://yunvoo.com//blog/2015/07/22/effective-cpp-4.html</id>
    <published>2015-07-21T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.409Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Item 4: Make sure that objects are initialized before they’re used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出于效率原因，C++不保证&lt;strong&gt;内置类型数据成员&lt;/strong&gt;的初始化。对于成员变量的内置类型，&lt;br&gt;会在构造函数进入之前进行初始化。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    B b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中数据成员&lt;code&gt;a&lt;/code&gt;是基本数据类型，&lt;code&gt;b&lt;/code&gt;是成员对象。有些情况下C++会初始化&lt;code&gt;a&lt;/code&gt;，有些情况下则不会。&lt;br&gt;对象类型的&lt;code&gt;b&lt;/code&gt;却是总会被初始化的，它的无参数的构造函数将被调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有成员对象的类称为封闭类（&lt;code&gt;C&lt;/code&gt;就是一个），如果&lt;code&gt;B&lt;/code&gt;没有不带参数的构造函数，则必须在&lt;code&gt;C&lt;/code&gt;的构造函数中进行&lt;code&gt;b&lt;/code&gt;的初始化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C++中变量的初始化规则较为复杂，大致的规则是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于C风格的C++：如果初始化会产生额外的负担，则不会初始化。&lt;/li&gt;
&lt;li&gt;对于面向对象风格的C++：类的构造函数中一般都会进行所有成员的初始化（所以你也应该这样做！）。&lt;/li&gt;
&lt;li&gt;全局/静态变量会自动初始化，自动变量（栈里面的）不会自动初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;完整的讨论可以参考：&lt;a href=&quot;!--￼5--&quot;&gt;C++手稿：那些变量会自动初始化？&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;构造函数中初始化所有成员&quot;&gt;&lt;a href=&quot;#构造函数中初始化所有成员&quot; class=&quot;headerlink&quot; title=&quot;构造函数中初始化所有成员&quot;&gt;&lt;/a&gt;构造函数中初始化所有成员&lt;/h1&gt;&lt;p&gt;在C++程序设计中的绝大多数场景下，由构造函数上进行变量的初始化。于是规则很简单：在构造函数中初始化所有成员。&lt;br&gt;值得注意的是，在构造函数进入之前成员已经进行了初始化。下面的代码会使得成员对象构造两次：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   B b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   C()&amp;#123; b = B(); &amp;#125;  &lt;span class=&quot;comment&quot;&gt;// 这个是赋值啦&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;正确的做法是在构造函数前给出初始化列表：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    B b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    C():b(), i()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C::C() : b(), i(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;在构造函数前总是列出所有成员变量，以免遗漏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;类静态变量的初始化&quot;&gt;&lt;a href=&quot;#类静态变量的初始化&quot; class=&quot;headerlink&quot; title=&quot;类静态变量的初始化&quot;&gt;&lt;/a&gt;类静态变量的初始化&lt;/h1&gt;&lt;p&gt;类的静态变量除了在类声明中进行声明外，还需要在类声明外进行定义。&lt;br&gt;（&lt;code&gt;static const int&lt;/code&gt;是个例外，参见：&lt;a href=&quot;/2015/07/21/effective-cpp-2.html&quot;&gt;Effective C++笔记：避免使用define&lt;/a&gt;）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态变量的生命周期不同于栈或者堆中的对象，从它被构造开始一直存在，直到程序结束。&lt;br&gt;包括全局变量、命名空间下的变量、类中和函数中定义的&lt;code&gt;static&lt;/code&gt;对象。&lt;br&gt;其中，定义在函数中的称为 local static，其他的称为 non-local static。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多个编译单元的 non-local static 对象初始化次序是不确定的。因此可能会在使用时造成未初始化的问题，&lt;br&gt;解决办法便是把它变成一个 local static，C++保证了在第一次函数调用遇到该 local static 声明时，&lt;br&gt;它会被初始化。这也是Singleton(local static) 的典型实现：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; FileSystem&amp;#123;...&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;FileSystem&amp;amp; &lt;span class=&quot;title&quot;&gt;tfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//将在首次进入函数时构造&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; FileSystem fs;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下提供较完整的Signleton C++实现：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Singleton&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Singleton&amp;amp;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Singleton&amp;amp; rhs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton&amp;amp; &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;一旦声明了任何形式的构造函数（包括拷贝构造函数），编译器将不会生成默认的无参构造函数。所以上述的无参数的构造函数可以省略。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Item 4: Make sure that objects are initialized before they’re used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出于效率原因，C++不保证&lt;strong&gt;内置类型数据成员&lt;/strong&gt;的初始化。对于成员变量的内置类型，&lt;br&gt;会在构造函数进入之前进行初始化。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    B b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中数据成员&lt;code&gt;a&lt;/code&gt;是基本数据类型，&lt;code&gt;b&lt;/code&gt;是成员对象。有些情况下C++会初始化&lt;code&gt;a&lt;/code&gt;，有些情况下则不会。&lt;br&gt;对象类型的&lt;code&gt;b&lt;/code&gt;却是总会被初始化的，它的无参数的构造函数将被调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有成员对象的类称为封闭类（&lt;code&gt;C&lt;/code&gt;就是一个），如果&lt;code&gt;B&lt;/code&gt;没有不带参数的构造函数，则必须在&lt;code&gt;C&lt;/code&gt;的构造函数中进行&lt;code&gt;b&lt;/code&gt;的初始化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;C++中变量的初始化规则较为复杂，大致的规则是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于C风格的C++：如果初始化会产生额外的负担，则不会初始化。&lt;/li&gt;
&lt;li&gt;对于面向对象风格的C++：类的构造函数中一般都会进行所有成员的初始化（所以你也应该这样做！）。&lt;/li&gt;
&lt;li&gt;全局/静态变量会自动初始化，自动变量（栈里面的）不会自动初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;完整的讨论可以参考：&lt;a href=&quot;!--￼5--&quot;&gt;C++手稿：那些变量会自动初始化？&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++ 栈 编译 全局变量 构造函数 静态变量 拷贝构造函数" scheme="http://yunvoo.com/tags/C-%E6%A0%88-%E7%BC%96%E8%AF%91-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Item 3：尽量使用常量</title>
    <link href="http://yunvoo.com//blog/2015/07/21/effective-cpp-3.html"/>
    <id>http://yunvoo.com//blog/2015/07/21/effective-cpp-3.html</id>
    <published>2015-07-20T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.422Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Item 3: Use const whenever possible&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽量使用常量。不需多说，这是防卫型（defensive）程序设计的原则，&lt;br&gt;尽量使用常量限定符，从而防止客户错误地使用你的代码。&lt;/p&gt;
&lt;h1 id=&quot;常量的声明&quot;&gt;&lt;a href=&quot;#常量的声明&quot; class=&quot;headerlink&quot; title=&quot;常量的声明&quot;&gt;&lt;/a&gt;常量的声明&lt;/h1&gt;&lt;p&gt;总结一下各种指针的声明方式吧：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; greeting[] = &lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *p = greeting;                    &lt;span class=&quot;comment&quot;&gt;// non-const pointer, non-const data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *p = greeting;              &lt;span class=&quot;comment&quot;&gt;// non-const pointer, const data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p = greeting;             &lt;span class=&quot;comment&quot;&gt;// const pointer, non-const data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p = greeting;       &lt;span class=&quot;comment&quot;&gt;// const pointer, const data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;出现在&lt;code&gt;*&lt;/code&gt;左边则被指向的对象是常量，出现在&lt;code&gt;*&lt;/code&gt;右边则指针本身是常量。&lt;br&gt;然而对于常量对象，有人把&lt;code&gt;const&lt;/code&gt;放在类型左边，有人把&lt;code&gt;const&lt;/code&gt;放在&lt;code&gt;*&lt;/code&gt;左边，都是可以的：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Widget *pw)&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// f1 takes a pointer to a constant Widget object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Widget &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; *pw)&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 等效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;STL的iterator也是类似的，如果你希望指针本身是常量，可以声明&lt;code&gt;const iterator&lt;/code&gt;；&lt;br&gt;如果你希望指针指向的对象是常量，请使用&lt;code&gt;const_iterator&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; vec;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// iter acts like a T* const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator iter = vec.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*iter = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;                              &lt;span class=&quot;comment&quot;&gt;// OK, changes what iter points to&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;++iter;                                  &lt;span class=&quot;comment&quot;&gt;// error! iter is const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//cIter acts like a const T*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::const_iterator cIter = vec.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*cIter = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;                             &lt;span class=&quot;comment&quot;&gt;// error! *cIter is const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;++cIter;                                 &lt;span class=&quot;comment&quot;&gt;// fine, changes cIter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值声明为常量可以防止你的代码被错误地使用，例如实数相加的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Rational &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;*(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Rational&amp;amp; lhs, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Rational&amp;amp; rhs);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当用户错误地使用&lt;code&gt;=&lt;/code&gt;时：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Rational a, b, c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a * b = c)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编译器便会给出错误：不可赋值给常量。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;常量成员方法&quot;&gt;&lt;a href=&quot;#常量成员方法&quot; class=&quot;headerlink&quot; title=&quot;常量成员方法&quot;&gt;&lt;/a&gt;常量成员方法&lt;/h1&gt;&lt;p&gt;声明常量成员函数是为了确定哪些方法可以通过常量对象来访问，另外一方面让接口更加易懂：&lt;br&gt;很容易知道哪些方法会改变对象，哪些不会。&lt;/p&gt;
&lt;p&gt;成员方法添加常量限定符属于函数重载。常量对象只能调用常量方法，&lt;br&gt;非常量对象优先调用非常量方法，如不存在会调用同名常量方法。&lt;br&gt;常量成员函数也可以在类声明外定义，但声明和定义都需要指定&lt;code&gt;const&lt;/code&gt;关键字。&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; TextBlock &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; position) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// operator[] for&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; text[position]; &amp;#125;                           &lt;span class=&quot;comment&quot;&gt;// const objects&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; position)               &lt;span class=&quot;comment&quot;&gt;// operator[] for&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; text[position]; &amp;#125;                           &lt;span class=&quot;comment&quot;&gt;// non-const objects&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;TextBlock &lt;span class=&quot;title&quot;&gt;tb&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; TextBlock &lt;span class=&quot;title&quot;&gt;ctb&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;World&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tb[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;;             &lt;span class=&quot;comment&quot;&gt;// fine — writing a non-const TextBlock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctb[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;;            &lt;span class=&quot;comment&quot;&gt;// error! — writing a const TextBlock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;比特常量和逻辑常量&quot;&gt;&lt;a href=&quot;#比特常量和逻辑常量&quot; class=&quot;headerlink&quot; title=&quot;比特常量和逻辑常量&quot;&gt;&lt;/a&gt;比特常量和逻辑常量&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;比特常量&lt;/strong&gt;（bitwise constness）：如果一个方法不改变对象的任何非静态变量，那么该方法是常量方法。&lt;br&gt;比特常量是C++定义常量的方式，然而一个满足比特常量的方法，却不见得表现得像个常量，&lt;br&gt;尤其是数据成员是指针时：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; TextBlock&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pos) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; text[pos];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; TextBlock tb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *p = &amp;amp;tb[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*p = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为&lt;code&gt;char* text&lt;/code&gt;并未发生改变，所以编译器认为我们的操作都是合法的。&lt;br&gt;然而我们定义了一个常量对象&lt;code&gt;tb&lt;/code&gt;，只调用它的常量方法，却能够修改&lt;code&gt;tb&lt;/code&gt;的数据。&lt;br&gt;对数据的操作甚至可以放在&lt;code&gt;operator[]()&lt;/code&gt;方法里面。&lt;/p&gt;
&lt;p&gt;这一点不合理之处引发了&lt;strong&gt;逻辑常量&lt;/strong&gt;（logical constness）的讨论：常量方法可以修改数据成员，&lt;br&gt;只要客户检测不到变化就可以。可是常量方法修改数据成员C++编译器不会同意的！这时我们需要&lt;code&gt;mutable&lt;/code&gt;限定符：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CTextBlock &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; length() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *pText;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;mutable&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; textLength;         &lt;span class=&quot;comment&quot;&gt;// these data members may&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;mutable&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; lengthIsValid;             &lt;span class=&quot;comment&quot;&gt;// always be modified&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;                                     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; CTextBlock::length() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!lengthIsValid) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    textLength = &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(pText);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lengthIsValid = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; textLength;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;避免常量-非常量方法的重复&quot;&gt;&lt;a href=&quot;#避免常量-非常量方法的重复&quot; class=&quot;headerlink&quot; title=&quot;避免常量/非常量方法的重复&quot;&gt;&lt;/a&gt;避免常量/非常量方法的重复&lt;/h1&gt;&lt;p&gt;通常我们需要定义成对的常量和普通方法，只是返回值的修改权限不同。&lt;br&gt;当然我们不希望重新编写方法的逻辑。最先想到的方法是常量方法调用普通方法，然而这是C++语法不允许的。&lt;br&gt;于是我们只能用普通方法调用常量方法，并做相应的类型转换：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; pos) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;[](&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; pos)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;amp;&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; TextBlock&amp;amp;&amp;gt;(*&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [pos]   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;*this&lt;/code&gt;的类型是&lt;code&gt;TextBlock&lt;/code&gt;，先把它强制隐式转换为&lt;code&gt;const TextBlock&lt;/code&gt;，这样我们才能调用那个常量方法。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;operator[](size_t) const&lt;/code&gt;，得到的返回值类型为&lt;code&gt;const char&amp;amp;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;把返回值去掉&lt;code&gt;const&lt;/code&gt;属性，得到类型为&lt;code&gt;char&amp;amp;&lt;/code&gt;的返回值。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Item 3: Use const whenever possible&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽量使用常量。不需多说，这是防卫型（defensive）程序设计的原则，&lt;br&gt;尽量使用常量限定符，从而防止客户错误地使用你的代码。&lt;/p&gt;
&lt;h1 id=&quot;常量的声明&quot;&gt;&lt;a href=&quot;#常量的声明&quot; class=&quot;headerlink&quot; title=&quot;常量的声明&quot;&gt;&lt;/a&gt;常量的声明&lt;/h1&gt;&lt;p&gt;总结一下各种指针的声明方式吧：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; greeting[] = &lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *p = greeting;                    &lt;span class=&quot;comment&quot;&gt;// non-const pointer, non-const data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *p = greeting;              &lt;span class=&quot;comment&quot;&gt;// non-const pointer, const data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p = greeting;             &lt;span class=&quot;comment&quot;&gt;// const pointer, non-const data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p = greeting;       &lt;span class=&quot;comment&quot;&gt;// const pointer, const data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;出现在&lt;code&gt;*&lt;/code&gt;左边则被指向的对象是常量，出现在&lt;code&gt;*&lt;/code&gt;右边则指针本身是常量。&lt;br&gt;然而对于常量对象，有人把&lt;code&gt;const&lt;/code&gt;放在类型左边，有人把&lt;code&gt;const&lt;/code&gt;放在&lt;code&gt;*&lt;/code&gt;左边，都是可以的：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Widget *pw)&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// f1 takes a pointer to a constant Widget object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Widget &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; *pw)&lt;/span&gt;&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 等效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;STL的iterator也是类似的，如果你希望指针本身是常量，可以声明&lt;code&gt;const iterator&lt;/code&gt;；&lt;br&gt;如果你希望指针指向的对象是常量，请使用&lt;code&gt;const_iterator&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; vec;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// iter acts like a T* const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator iter = vec.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*iter = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;                              &lt;span class=&quot;comment&quot;&gt;// OK, changes what iter points to&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;++iter;                                  &lt;span class=&quot;comment&quot;&gt;// error! iter is const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//cIter acts like a const T*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::const_iterator cIter = vec.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*cIter = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;                             &lt;span class=&quot;comment&quot;&gt;// error! *cIter is const&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;++cIter;                                 &lt;span class=&quot;comment&quot;&gt;// fine, changes cIter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值声明为常量可以防止你的代码被错误地使用，例如实数相加的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Rational &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;*(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Rational&amp;amp; lhs, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Rational&amp;amp; rhs);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当用户错误地使用&lt;code&gt;=&lt;/code&gt;时：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Rational a, b, c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a * b = c)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编译器便会给出错误：不可赋值给常量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ STL 宏 常量 指针 编译 函数重载" scheme="http://yunvoo.com/tags/C-STL-%E5%AE%8F-%E5%B8%B8%E9%87%8F-%E6%8C%87%E9%92%88-%E7%BC%96%E8%AF%91-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Item 2：避免使用define</title>
    <link href="http://yunvoo.com//blog/2015/07/20/effective-cpp-2.html"/>
    <id>http://yunvoo.com//blog/2015/07/20/effective-cpp-2.html</id>
    <published>2015-07-19T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.434Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Item 2: Prefer consts, enums, and inlines to #defines&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽量使用常量、枚举和内联函数，代替&lt;code&gt;#define&lt;/code&gt;。我们知道&lt;code&gt;#define&lt;/code&gt;定义的宏会在编译时进行替换，属于模块化程序设计的概念。&lt;br&gt;宏是全局的，面向对象程序设计中破坏了封装。因此在C++中尽量避免它！&lt;/p&gt;
&lt;p&gt;接着我们具体来看&lt;code&gt;#define&lt;/code&gt;造成的问题。&lt;/p&gt;
&lt;h1 id=&quot;不易理解&quot;&gt;&lt;a href=&quot;#不易理解&quot; class=&quot;headerlink&quot; title=&quot;不易理解&quot;&gt;&lt;/a&gt;不易理解&lt;/h1&gt;&lt;p&gt;众所周知，由于预处理器会直接替换的原因，宏定义最好用括号括起来。&lt;code&gt;#define&lt;/code&gt;函数将会产生出乎意料的结果：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAX(a,b) a&amp;gt;b?a:b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MAX(i++,j)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;自加次数将取决于&lt;code&gt;j&lt;/code&gt;的大小，然而调用者并不知情。宏的行为不易理解，本质上是因为宏并非C++语言的一部分，它只是源代码的预处理手段。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;不利于调试&quot;&gt;&lt;a href=&quot;#不利于调试&quot; class=&quot;headerlink&quot; title=&quot;不利于调试&quot;&gt;&lt;/a&gt;不利于调试&lt;/h1&gt;&lt;p&gt;宏替换发生在编译时，语法检查之前。因此相关的编译错误中不会出现宏名称，我们不知道是哪个宏出了问题。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; PERSON alice&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PERSON = bob;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果&lt;code&gt;alice&lt;/code&gt;未定义，&lt;code&gt;PERSON=bob;&lt;/code&gt;便会出错：&lt;code&gt;use of undeclared identifier &amp;#39;alice&amp;#39;&lt;/code&gt;。&lt;br&gt;然而我们可能不知道&lt;code&gt;alice&lt;/code&gt;是什么东西，&lt;code&gt;PERSON&lt;/code&gt;才是我们定义的“变量”。&lt;/p&gt;
&lt;p&gt;宏替换是在预处理过程中进行的，原则上讲编译器不知道宏的概念。然而，在现代的编译器中（例如&lt;code&gt;Apple LLVM version 6.0&lt;/code&gt;），&lt;br&gt;编译器会记录宏替换信息，在编译错误中给出宏的名称：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test.cpp:8:5: error: use of undeclared identifier &amp;apos;alice&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PERSON  = bob;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ^&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test.cpp:4:16: note: expanded from macro &amp;apos;PERSON&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define PERSON alice;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               ^&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;于是，Meyers提到的这个问题已经不存在了。然而作者的本意在于：尽量使用编译器，而不是预处理器。&lt;br&gt;因为&lt;code&gt;#define&lt;/code&gt;并不是C++语言的一部分。&lt;/p&gt;
&lt;h1 id=&quot;enum-比-const-更好用&quot;&gt;&lt;a href=&quot;#enum-比-const-更好用&quot; class=&quot;headerlink&quot; title=&quot;enum 比 const 更好用&quot;&gt;&lt;/a&gt;enum 比 const 更好用&lt;/h1&gt;&lt;p&gt;既然&lt;code&gt;#define&lt;/code&gt;不能封装在一个类中，我们可以用&lt;code&gt;static const&lt;/code&gt;来定义一个常量，并把它的作用于局限在当前类：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; NUM = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[NUM];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常C++要求所有的声明都给出定义，然而数值类型（&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;）的静态常量可以只给声明。这里的&lt;code&gt;NUM&lt;/code&gt;就是一个例子。&lt;br&gt;然而，如果你想取&lt;code&gt;NUM&lt;/code&gt;的地址，则会得到编译错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Undefined symbols for architecture x86_64:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;C::NUM&amp;quot;, referenced from:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      _main in a-88bbac.o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ld: symbol(s) not found for architecture x86_64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clang: error: linker command failed with exit code 1 (use -v to see invocation)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因此如果你要取地址，那么就给出它的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; NUM = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[NUM];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; C::NUM;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;因为声明&lt;code&gt;NUM&lt;/code&gt;时已经给定了初始值，定义时不允许再次给初始值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果使用&lt;code&gt;enum&lt;/code&gt;，事情会简单很多：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; C&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; &amp;#123; NUM = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[NUM];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Item 2: Prefer consts, enums, and inlines to #defines&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽量使用常量、枚举和内联函数，代替&lt;code&gt;#define&lt;/code&gt;。我们知道&lt;code&gt;#define&lt;/code&gt;定义的宏会在编译时进行替换，属于模块化程序设计的概念。&lt;br&gt;宏是全局的，面向对象程序设计中破坏了封装。因此在C++中尽量避免它！&lt;/p&gt;
&lt;p&gt;接着我们具体来看&lt;code&gt;#define&lt;/code&gt;造成的问题。&lt;/p&gt;
&lt;h1 id=&quot;不易理解&quot;&gt;&lt;a href=&quot;#不易理解&quot; class=&quot;headerlink&quot; title=&quot;不易理解&quot;&gt;&lt;/a&gt;不易理解&lt;/h1&gt;&lt;p&gt;众所周知，由于预处理器会直接替换的原因，宏定义最好用括号括起来。&lt;code&gt;#define&lt;/code&gt;函数将会产生出乎意料的结果：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MAX(a,b) a&amp;gt;b?a:b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MAX(i++,j)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;i&lt;/code&gt;自加次数将取决于&lt;code&gt;j&lt;/code&gt;的大小，然而调用者并不知情。宏的行为不易理解，本质上是因为宏并非C++语言的一部分，它只是源代码的预处理手段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ 宏 封装 常量 编译 模块化" scheme="http://yunvoo.com/tags/C-%E5%AE%8F-%E5%B0%81%E8%A3%85-%E5%B8%B8%E9%87%8F-%E7%BC%96%E8%AF%91-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Item 1：将C++视作一系列的语言</title>
    <link href="http://yunvoo.com//blog/2015/07/19/effective-cpp-1.html"/>
    <id>http://yunvoo.com//blog/2015/07/19/effective-cpp-1.html</id>
    <published>2015-07-18T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.124Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Item 1: View C++ as a federation of languages&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最初，C++只是C语言加上一些面向对象的特性，所以C++的原名是“C with Classes”。&lt;br&gt;现在的C++已经逐渐成熟，成为一门&lt;strong&gt;多范式的程序设计语言&lt;/strong&gt;（multiparadigm programming language）。同时支持过程式、面向对象、函数式、泛型编程，以及元编程。&lt;/p&gt;
&lt;p&gt;C++的灵活使得它在很多问题上并没有统一的规则，而是取决于具体的程序设计范式和当前架构的设计意图。这样的情况下，我们最好把C++看做是一系列的编程语言，而非一种特定的编程语言。&lt;/p&gt;
&lt;p&gt;C++有四种主要的子语言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C。C++是基于C设计的，你可以只使用C++中C的那部分语法。此时你会发现你的程序反映的完全是C的特征：没有模板、没有异常、没有重载。&lt;/li&gt;
&lt;li&gt;Object-Oriented C++。面向对象程序设计也是C++的设计初衷：构造与析构、封装与继承、多态、动态绑定的虚函数。&lt;/li&gt;
&lt;li&gt;Template C++。这是C++的泛型编程部分，多数程序员很少涉及，但模板在很多情况下仍然很方便。另外&lt;strong&gt;模板元编程&lt;/strong&gt;（template metaprogramming）也是一个新兴的程序设计范式，虽然有点非主流。&lt;/li&gt;
&lt;li&gt;STL。这是一个特殊的模板库，它的容器、迭代器和算法优雅地结合在一起，只是在使用时你需要遵循它的程序设计惯例。当然你也可以基于其他想法来构建模板库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之C++并非单一的一门语言，它有很多不同的规则集。因而C++可以被视为四种主要子语言的集合，每个子语言都有自己的程序设计惯例。&lt;/p&gt;
&lt;p&gt;C++程序设计的惯例并非一尘不变，而是取决于你使用C++语言的哪一部分。例如，&lt;br&gt;在基于C语言的程序设计中，基本类型传参时传值比传引用更有效率。&lt;br&gt;然而当你接触Object-Oriented C++时会发现，传常量指针是更好的选择。&lt;br&gt;但是你如果又碰到了STL，其中的迭代器和函数对象都是基于C语言的指针而设计的，&lt;br&gt;这时又回到了原来的规则：传值比传引用更好。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Item 1: View C++ as a federation of languages&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最初，C++只是C语言加上一些面向对象的特性，所以C++的原名是“C with Classes”。&lt;br&gt;现在的C
    
    </summary>
    
    
      <category term="C++ Objective-C STL 多态 封装 模板 继承 虚函数 动态绑定" scheme="http://yunvoo.com/tags/C-Objective-C-STL-%E5%A4%9A%E6%80%81-%E5%B0%81%E8%A3%85-%E6%A8%A1%E6%9D%BF-%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>在VIM下写C++能有多爽？</title>
    <link href="http://yunvoo.com//blog/2015/07/18/vim-cpp.html"/>
    <id>http://yunvoo.com//blog/2015/07/18/vim-cpp.html</id>
    <published>2015-07-17T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.133Z</updated>
    
    <content type="html">&lt;p&gt;我是坚定的Vim党，因为和命令行的集成如此之好，Vim可以解决任何问题。然而在这个世界上，即便是最好用的工具也是需要配置的。&lt;br&gt;由于最近在写C++，经过一番配置后，小编写C++已经感到非常爽了，于是决定用一篇文章来记录如何打造一个适合写C++的Vim编辑器！&lt;br&gt;包括C++的自动补全、括号引号匹配、格式化、注释、编译运行快捷键等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小编之前在&lt;a href=&quot;!--￼6--&quot;&gt;Vim初级：配置和使用&lt;/a&gt;中介绍了Vim的基本配置与使用，&lt;a href=&quot;!--￼7--&quot;&gt;感受Vim的强大：进阶技巧&lt;/a&gt;中介绍了更加方便的高级使用技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基础设置&quot;&gt;&lt;a href=&quot;#基础设置&quot; class=&quot;headerlink&quot; title=&quot;基础设置&quot;&gt;&lt;/a&gt;基础设置&lt;/h1&gt;&lt;p&gt;稍微熟悉Vim的小伙伴都会知道这个文件&lt;code&gt;~/.vimrc&lt;/code&gt;，如同绝大多数的Unix软件，Vim也是用基于文本的配置文件。&lt;br&gt;当前用户的Vim配置便存储在这个文件当中，该文件的每一行便是一个配置项（&lt;code&gt;function&lt;/code&gt;除外）。&lt;/p&gt;
&lt;p&gt;配置文件中的所有语句都会在打开Vim时，在Ex模式下执行。例如，我们在Vim中打开行号：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;:&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们便可以在配置文件中加入：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&quot; ~/.vim&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同样重要的配置还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开语法高亮：&lt;code&gt;syntax on&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tab大小：&lt;code&gt;set tabstop=4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缩进大小：&lt;code&gt;set shiftwidth=4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim是一个典型的Unix程序，上述命令都有缩写啦：number(nu), tabstop(ts), shiftwidth(sw), etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于基础配置项的信息，请参考我的另一篇博客： &lt;a href=&quot;/2013/11/08/vim-config/&quot;&gt;vim 的配置与使用&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;自动补全&quot;&gt;&lt;a href=&quot;#自动补全&quot; class=&quot;headerlink&quot; title=&quot;自动补全&quot;&gt;&lt;/a&gt;自动补全&lt;/h1&gt;&lt;p&gt;自动补全恐怕是代码编辑器最重要的特性了，我们暂且不提它毁了多少人的面试之路。&lt;/p&gt;
&lt;p&gt;由于Vim插件的风格、使用方式太过多样化，多语言的自动补全一直存在各种冲突，需要大量精力才能调通。&lt;br&gt;然而Github的出现给Vim插件带来了新的活力，现在我们通过基于Github的Vundle来安装插件，而不需要手动去vim.org上找插件了。&lt;/p&gt;
&lt;p&gt;废话少说，我推荐的插件叫做&lt;a href=&quot;https://github.com/Valloric/YouCompleteMe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YouCompleteMe&lt;/a&gt;，看图！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/youcompleteme.gif&quot; alt=&quot;you complete me&quot;&gt;&lt;/p&gt;
&lt;p&gt;YouCompleteMe功能很全：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动补全，在你写一个名称的过程中，会出现提示列表，同时给出每一项的函数签名（函数形参列表）。&lt;/li&gt;
&lt;li&gt;语法错误、警告的提示。比如变量未使用、函数未定义等等，很多编译warning都会直接提示出来，特别神奇。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置很容易，但需要先安装&lt;a href=&quot;https://github.com/gmarik/vundle#about&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vundle&lt;/a&gt;（如果你没有的话）。注意&lt;code&gt;vim +PluginInstall&lt;/code&gt;后还需要去&lt;code&gt;~/.vim/bundle/YouCompleteMe&lt;/code&gt;中&lt;code&gt;./install.sh&lt;/code&gt;一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是MacOS用户，确保你的Vim升级到了7.4. 如何使用HomeBrew本文就不唠叨了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;括号-引号匹配&quot;&gt;&lt;a href=&quot;#括号-引号匹配&quot; class=&quot;headerlink&quot; title=&quot;括号/引号匹配&quot;&gt;&lt;/a&gt;括号/引号匹配&lt;/h1&gt;&lt;p&gt;括号和引号的自动补全和智能匹配。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入前大括号补全后大括号&lt;/li&gt;
&lt;li&gt;在一对括号之间回车，自动分为3行并调整缩进&lt;/li&gt;
&lt;li&gt;输入前引号自动补全后引号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;凡此种种。。。我觉的第二条是最实用的功能，尤其是写函数和类的时候。&lt;/p&gt;
&lt;p&gt;上述的各种括号、引号匹配都可以用delimitMate来解决，官网：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Raimondi/delimitMate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Raimondi/delimitMate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;delimitMate可以通过Vundle的形式安装。在&lt;code&gt;~/.vimrc&lt;/code&gt;添加&lt;code&gt;Plugin &amp;#39;Raimondi/delimitMate&amp;#39;&lt;/code&gt;并&lt;code&gt;PluginInstall&lt;/code&gt;，重新打开Vim后括号就可以自动补全啦！&lt;/p&gt;
&lt;h1 id=&quot;Formatter&quot;&gt;&lt;a href=&quot;#Formatter&quot; class=&quot;headerlink&quot; title=&quot;Formatter&quot;&gt;&lt;/a&gt;Formatter&lt;/h1&gt;&lt;p&gt;格式化程序对于我们懒人和强迫症用户来讲是非常需要的。Vim的默认配置中提供了格式化功能，&lt;br&gt;但显然我们要的更多！比如我希望：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前大括号不换行，而后大括号换行&lt;/li&gt;
&lt;li&gt;所有运算符两边都有空格&lt;/li&gt;
&lt;li&gt;一键格式化当前文件&lt;/li&gt;
&lt;li&gt;保存时自动格式化&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里推荐的插件叫做&lt;a href=&quot;https://github.com/Chiel92/vim-autoformat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vim-autoformat&lt;/a&gt;，上述的需求都能完美地解决。参照文档安装就好了。&lt;/p&gt;
&lt;p&gt;需要注意的是，vim-autoformat只是格式化程序框架，它依赖于代码风格检查工具来进行格式化。&lt;br&gt;我们需要单独安装这些工具：astyle、js-beautify等。这里有完整的列表：&lt;a href=&quot;https://github.com/Chiel92/vim-autoformat#default-formatprograms&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Chiel92/vim-autoformat#default-formatprograms&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果你希望自定义代码风格，可以在&lt;code&gt;.vimrc&lt;/code&gt;中添加个性化的formatter：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;g:formatdef_harttle&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;&quot;astyle --style=attach --pad-oper&quot;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;g:formatters_cpp&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&#39;harttle&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;g:formatters_java&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&#39;harttle&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如我安装了astyle，这里定义一个formatter叫做harttle。然后，把它设置成cpp和java的formatter。&lt;br&gt;至于&lt;code&gt;astyle --style=attach --pad-oper&lt;/code&gt;为什么这样写，这是一个Bash命令，这些参数你可以去查看&lt;a href=&quot;http://astyle.sourceforge.net/astyle.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Astyle 的文档&lt;/a&gt;。&lt;br&gt;来一个快捷键F3格式化当前文件：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&quot; file: ~/.vimrc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;noremap&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;F3&amp;gt;&lt;/span&gt; :Autoformat&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;看图！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/vim-format@2x.png&quot; alt=&quot;vim format&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h1&gt;&lt;p&gt;注释、反注释是代码编辑器的常用操作，我们也可以方便地在Vim中设置快捷键。&lt;br&gt;然而因为不同语言的注释风格不同，我们可能需要在&lt;code&gt;ftplugin&lt;/code&gt;下写多个配置文件，总之很烦人。&lt;br&gt;可以引入一个称为NERD Commenter的插件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/scrooloose/nerdcommenter&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/scrooloose/nerdcommenter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个在社区很火的插件，O(∩_∩)O~。下载后直接复制到&lt;code&gt;~/.vim&lt;/code&gt;下面即可。&lt;br&gt;如果你希望看到它的文档，只需要更新VIM DOC：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;:&lt;span class=&quot;keyword&quot;&gt;helptags&lt;/span&gt; ~/.&lt;span class=&quot;keyword&quot;&gt;vim&lt;/span&gt;/doc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此后，按下&lt;code&gt;\cc&lt;/code&gt;即可注释，&lt;code&gt;\cu&lt;/code&gt;反注释。前面可以加一个行数~&lt;/p&gt;
&lt;h1 id=&quot;编译-运行&quot;&gt;&lt;a href=&quot;#编译-运行&quot; class=&quot;headerlink&quot; title=&quot;编译/运行&quot;&gt;&lt;/a&gt;编译/运行&lt;/h1&gt;&lt;p&gt;如果你已经能熟练地定义Vim快捷键，就不必往下看了。&lt;/p&gt;
&lt;p&gt;下面三行分别设置了运行、编译、调试的快捷键，&lt;code&gt;n&lt;/code&gt;表示该快捷键在normal模式下起作用；&lt;br&gt;&lt;code&gt;nore&lt;/code&gt;表示该定义不会递归地传递；&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;是回车（carriage return），&lt;code&gt;!&lt;/code&gt;表示执行Shell命令。&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;nnoremap&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;F5&amp;gt;&lt;/span&gt;   &lt;span class=&quot;symbol&quot;&gt;&amp;lt;Esc&amp;gt;&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;:!g++ -std=&lt;span class=&quot;keyword&quot;&gt;c&lt;/span&gt;++&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; % -&lt;span class=&quot;keyword&quot;&gt;o&lt;/span&gt; /tmp/&lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt;.out &amp;amp;&amp;amp; /tmp/&lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt;.out&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;nnoremap&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;F7&amp;gt;&lt;/span&gt;   &lt;span class=&quot;symbol&quot;&gt;&amp;lt;Esc&amp;gt;&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;:!g++ -std=&lt;span class=&quot;keyword&quot;&gt;c&lt;/span&gt;++&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; %&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;nnoremap&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;C-F5&amp;gt;&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;Esc&amp;gt;&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;:!g++ -std=&lt;span class=&quot;keyword&quot;&gt;c&lt;/span&gt;++&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; -g % -&lt;span class=&quot;keyword&quot;&gt;o&lt;/span&gt; /tmp/&lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt;.out &amp;amp;&amp;amp; gdb /tmp/&lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt;.out&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，如果你把上述代码直接添加到&lt;code&gt;~/.vimrc&lt;/code&gt;中，所有类型的文件都会拥有上述三个快捷键。&lt;br&gt;这可能是我们不希望的结果，我们希望每种文件类型的&lt;code&gt;&amp;lt;F5&amp;gt;&lt;/code&gt;执行自己的运行命令。&lt;/p&gt;
&lt;p&gt;这需要进行文件类型识别和定义文件类型插件，请参考我的另一篇文章：&lt;a href=&quot;/2015/07/17/vim-advanced.html&quot;&gt;感受Vim的强大：进阶技巧&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我是坚定的Vim党，因为和命令行的集成如此之好，Vim可以解决任何问题。然而在这个世界上，即便是最好用的工具也是需要配置的。&lt;br&gt;由于最近在写C++，经过一番配置后，小编写C++已经感到非常爽了，于是决定用一篇文章来记录如何打造一个适合写C++的Vim编辑器！&lt;br&gt;包括C++的自动补全、括号引号匹配、格式化、注释、编译运行快捷键等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小编之前在&lt;a href=&quot;!--￼6--&quot;&gt;Vim初级：配置和使用&lt;/a&gt;中介绍了Vim的基本配置与使用，&lt;a href=&quot;!--￼7--&quot;&gt;感受Vim的强大：进阶技巧&lt;/a&gt;中介绍了更加方便的高级使用技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基础设置&quot;&gt;&lt;a href=&quot;#基础设置&quot; class=&quot;headerlink&quot; title=&quot;基础设置&quot;&gt;&lt;/a&gt;基础设置&lt;/h1&gt;&lt;p&gt;稍微熟悉Vim的小伙伴都会知道这个文件&lt;code&gt;~/.vimrc&lt;/code&gt;，如同绝大多数的Unix软件，Vim也是用基于文本的配置文件。&lt;br&gt;当前用户的Vim配置便存储在这个文件当中，该文件的每一行便是一个配置项（&lt;code&gt;function&lt;/code&gt;除外）。&lt;/p&gt;
&lt;p&gt;配置文件中的所有语句都会在打开Vim时，在Ex模式下执行。例如，我们在Vim中打开行号：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;:&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们便可以在配置文件中加入：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&quot; ~/.vim&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同样重要的配置还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开语法高亮：&lt;code&gt;syntax on&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tab大小：&lt;code&gt;set tabstop=4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缩进大小：&lt;code&gt;set shiftwidth=4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim是一个典型的Unix程序，上述命令都有缩写啦：number(nu), tabstop(ts), shiftwidth(sw), etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多关于基础配置项的信息，请参考我的另一篇博客： &lt;a href=&quot;/2013/11/08/vim-config/&quot;&gt;vim 的配置与使用&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;自动补全&quot;&gt;&lt;a href=&quot;#自动补全&quot; class=&quot;headerlink&quot; title=&quot;自动补全&quot;&gt;&lt;/a&gt;自动补全&lt;/h1&gt;&lt;p&gt;自动补全恐怕是代码编辑器最重要的特性了，我们暂且不提它毁了多少人的面试之路。&lt;/p&gt;
&lt;p&gt;由于Vim插件的风格、使用方式太过多样化，多语言的自动补全一直存在各种冲突，需要大量精力才能调通。&lt;br&gt;然而Github的出现给Vim插件带来了新的活力，现在我们通过基于Github的Vundle来安装插件，而不需要手动去vim.org上找插件了。&lt;/p&gt;
&lt;p&gt;废话少说，我推荐的插件叫做&lt;a href=&quot;https://github.com/Valloric/YouCompleteMe&quot;&gt;YouCompleteMe&lt;/a&gt;，看图！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/youcompleteme.gif&quot; alt=&quot;you complete me&quot;&gt;&lt;/p&gt;
&lt;p&gt;YouCompleteMe功能很全：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动补全，在你写一个名称的过程中，会出现提示列表，同时给出每一项的函数签名（函数形参列表）。&lt;/li&gt;
&lt;li&gt;语法错误、警告的提示。比如变量未使用、函数未定义等等，很多编译warning都会直接提示出来，特别神奇。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置很容易，但需要先安装&lt;a href=&quot;https://github.com/gmarik/vundle#about&quot;&gt;Vundle&lt;/a&gt;（如果你没有的话）。注意&lt;code&gt;vim +PluginInstall&lt;/code&gt;后还需要去&lt;code&gt;~/.vim/bundle/YouCompleteMe&lt;/code&gt;中&lt;code&gt;./install.sh&lt;/code&gt;一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是MacOS用户，确保你的Vim升级到了7.4. 如何使用HomeBrew本文就不唠叨了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Bash C++ Github NERDCommenter Unix Vim Vundle YCM 快捷键" scheme="http://yunvoo.com/tags/Bash-C-Github-NERDCommenter-Unix-Vim-Vundle-YCM-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>感受Vim的强大：进阶技巧</title>
    <link href="http://yunvoo.com//blog/2015/07/17/vim-advanced.html"/>
    <id>http://yunvoo.com//blog/2015/07/17/vim-advanced.html</id>
    <published>2015-07-16T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.140Z</updated>
    
    <content type="html">&lt;p&gt;Vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。&lt;br&gt;如果你还没有使用过Vim，建议你先去看这个：&lt;a href=&quot;!--￼4--&quot;&gt;Vim初级：配置和使用&lt;/a&gt;。本文介绍一些Vim的高级特性。包括块编辑、宏录制、语法高亮、键盘映射、函数定义、文件类型识别与对应插件加载等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;英文文档：&lt;a href=&quot;http://vimdoc.sourceforge.net/htmldoc/，中文文档：http://vimcdoc.sourceforge.net/doc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://vimdoc.sourceforge.net/htmldoc/，中文文档：http://vimcdoc.sourceforge.net/doc/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;块编辑&quot;&gt;&lt;a href=&quot;#块编辑&quot; class=&quot;headerlink&quot; title=&quot;块编辑&quot;&gt;&lt;/a&gt;块编辑&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可视&lt;/strong&gt; 模式：&lt;code&gt;v&lt;/code&gt; 可进入visual模式，使用标准快捷键移动光标可选择文本块，之后可输入标准编辑命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;列编辑&lt;/strong&gt; 模式：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，移动光标将按列进行选中。例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;删除块注释：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，&lt;code&gt;ikjl&lt;/code&gt; 选中注释列，&lt;code&gt;&amp;lt;N&amp;gt;x&lt;/code&gt; 删除N个字符；&lt;/p&gt;
&lt;p&gt;添加块注释：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，&lt;code&gt;ikjl&lt;/code&gt; 选中要注释的行，&lt;code&gt;I&lt;/code&gt; 进入插入模式，输入几个注释字符，&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; 推出列编辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim所有的模式（即工作状态）如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(o) 普通模式: 输入命令时。&lt;/li&gt;
&lt;li&gt;(x) 可视模式: 可视区域高亮并输入命令时。&lt;/li&gt;
&lt;li&gt;(s) 选择模式: 类似于可视模式，但键入的字符对选择区进行替换。&lt;/li&gt;
&lt;li&gt;(o) 操作符等待模式: 操作符等待中 (“d”，”y”，”c” 等等之后)。&lt;/li&gt;
&lt;li&gt;(i) 插入模式: 也用于替换模式。&lt;/li&gt;
&lt;li&gt;(c) 命令行模式: 输入 “:” 或 “/“ 命令时。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;行尾块&lt;/strong&gt; ：因行尾参差不齐，块编辑一般用于行首、行间；行尾编辑要有一些技巧：&lt;code&gt;gg&lt;/code&gt;到文件头，&lt;code&gt;&amp;lt;Ctrl-v&amp;gt;&lt;/code&gt;进入块编辑模式，&lt;code&gt;G&lt;/code&gt;选择所有内容；&lt;code&gt;$A&lt;/code&gt;到行尾并进入插入模式，输入要插入的字符，&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;文件类型识别与对应插件加载&quot;&gt;&lt;a href=&quot;#文件类型识别与对应插件加载&quot; class=&quot;headerlink&quot; title=&quot;文件类型识别与对应插件加载&quot;&gt;&lt;/a&gt;文件类型识别与对应插件加载&lt;/h1&gt;&lt;p&gt;Vim可针对特定的文件，加载指定插件。以此来实现文件类型的特殊配置以及语法高亮。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参见：&lt;a href=&quot;http://vimcdoc.sourceforge.net/doc/filetype.html#filetype-plugins&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://vimcdoc.sourceforge.net/doc/filetype.html#filetype-plugins&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;filetype on&lt;/code&gt; 将开启文件识别，Vim 会在载入时做如下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行&lt;code&gt;$RUNTIMEPATH/filetype.vim&lt;/code&gt;，根据文件名判断类型&lt;/li&gt;
&lt;li&gt;如果需要的话，执行 &lt;code&gt;$RUNTIMEPATH/scripts.vim&lt;/code&gt;，进一步判断文件类型&lt;/li&gt;
&lt;li&gt;设置 Vim 的 &lt;code&gt;filetype&lt;/code&gt; 变量&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我们也可以通过诸如 &lt;code&gt;:set filetype=c&lt;/code&gt; 的命令来手动设置文件类型&lt;br&gt;如果不使用文件识别，我们可以运行 &lt;code&gt;au BufNewFile,BufRead *.plt  source ~/.vim/after/ftplugin/plt.vim&lt;/code&gt; 来使用 &lt;code&gt;plt.vim&lt;/code&gt; 初始化 &lt;code&gt;*.plt&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;更多关于&lt;code&gt;RUNTIMEPATH&lt;/code&gt; ：&lt;a href=&quot;http://vimcdoc.sourceforge.net/doc/options.html#&amp;#39;runtimepath&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://vimcdoc.sourceforge.net/doc/options.html#&amp;#39;runtimepath&lt;/a&gt;‘&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;filetype plugin on&lt;/code&gt; 允许Vim加载文件类型的插件，Vim会在载入时寻找并加载 &lt;code&gt;$RUNTIMEPATH/ftplugin.vim&lt;/code&gt;，该脚本会寻找并加载 &lt;code&gt;$RUNTIMEPATH/ftplugin/&amp;lt;filetype&amp;gt;.vim&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;~/.vim/ftplugin/cpp.vim&lt;/code&gt; 将在 cpp 文件类型被识别后自动载入。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同样，&lt;code&gt;~/.vim/after/ftplugin/cpp.vim&lt;/code&gt; 会在最后被调用，进而覆盖之前的配置。&lt;br&gt;另外，&lt;code&gt;filetype indent on&lt;/code&gt; 允许Vim加载该文件类型的缩进设置。即执行&lt;code&gt;RUNTIMEPATH/indent.vim&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;语法高亮&quot;&gt;&lt;a href=&quot;#语法高亮&quot; class=&quot;headerlink&quot; title=&quot;语法高亮&quot;&gt;&lt;/a&gt;语法高亮&lt;/h1&gt;&lt;p&gt;&lt;code&gt;syntax on&lt;/code&gt; 允许 Vim 加载文件类型的语法高亮配置，Vim会在载入时寻找并加载 &lt;code&gt;RUNTIMEPATH/syntax/&amp;lt;filetype&amp;gt;.vim&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;~/.vim/syntax/markdown.vim&lt;/code&gt; 将会对文件类型&lt;code&gt;markdown&lt;/code&gt; 进行语法高亮。&lt;/p&gt;
&lt;h1 id=&quot;键盘映射&quot;&gt;&lt;a href=&quot;#键盘映射&quot; class=&quot;headerlink&quot; title=&quot;键盘映射&quot;&gt;&lt;/a&gt;键盘映射&lt;/h1&gt;&lt;p&gt;Vim支持定义键盘映射来完成快捷键的功能，也就是将特定的按键映射为一系列按键与函数的序列。&lt;/p&gt;
&lt;p&gt;例如将 &lt;code&gt;F7&lt;/code&gt; 映射为编译当前java文件：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;F7&amp;gt;&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;Esc&amp;gt;&lt;/span&gt;:!javac %&amp;lt;&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;:&lt;/code&gt; 为进入Ex模式，&lt;code&gt;!&lt;/code&gt; 指定下面的命令在vim外执行，&lt;code&gt;%&lt;/code&gt; 为当前文件名，&lt;code&gt;%&amp;lt;&lt;/code&gt; 为不带扩展名的当前文件名，&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt; 为回车。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 命令有多种工作模式，如下表。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;map模式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;n&lt;/td&gt;
&lt;td&gt;普通&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;v&lt;/td&gt;
&lt;td&gt;可视和选择&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;s&lt;/td&gt;
&lt;td&gt;选择&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;x&lt;/td&gt;
&lt;td&gt;可视&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;o&lt;/td&gt;
&lt;td&gt;操作符等待&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;!&lt;/td&gt;
&lt;td&gt;插入和命令行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;i&lt;/td&gt;
&lt;td&gt;插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;l&lt;/td&gt;
&lt;td&gt;插入、命令行和 Lang-Arg 模式的 “:lmap” 映射&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;c&lt;/td&gt;
&lt;td&gt;命令行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中，&lt;code&gt;map&lt;/code&gt;模式可作为&lt;code&gt;map&lt;/code&gt;命令的前缀以指定其工作模式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;左边&lt;/th&gt;
&lt;th&gt;右边&lt;/th&gt;
&lt;th&gt;模式      &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;:map&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-nvo   &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:nm[ap]&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-n       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:vm[ap]&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-v       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:xm[ap]&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-x       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:smap&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-s      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:om[ap]&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-o      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:map!&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-ic     &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:im[ap]&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-i     &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:lm[ap]&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-l     &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:cm[ap]&lt;/td&gt;
&lt;td&gt;{lhs}&lt;/td&gt;
&lt;td&gt;{rhs}&lt;/td&gt;
&lt;td&gt;mapmode-c     &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;另外，可添加&lt;code&gt;nore&lt;/code&gt;指定非递归方式（取消传递性）。如&lt;code&gt;inoremap&lt;/code&gt;为插入模式下工作的&lt;code&gt;map&lt;/code&gt;，并且没有递归。&lt;/p&gt;
&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;p&gt;现在我们可以自定义快捷键了，如果希望在键盘映射中执行更复杂的功能，我们需要定义Vim函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数名必须以大写字母开始&lt;/li&gt;
&lt;li&gt;函数可以有返回值：&lt;code&gt;return something&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数可以有范围前缀。定义：&lt;code&gt;function s:Save()&lt;/code&gt;，调用：&lt;code&gt;call s:Save()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是函数调用的例子，按键F8时，进入拷贝模式（取消行号，鼠标进入visual模式）。&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&quot; key mapping&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;F8&amp;gt;&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;&amp;lt;Esc&amp;gt;&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;call&lt;/span&gt; ToggleCopy()&lt;span class=&quot;symbol&quot;&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&quot; global variable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;g:copymode&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&quot; function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ToggleCopy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;g:copymode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; mouse=&lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; nonumber&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; mouse=v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;g:copymode&lt;/span&gt;=!&lt;span class=&quot;variable&quot;&gt;g:copymode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;endfunction&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;录制宏&quot;&gt;&lt;a href=&quot;#录制宏&quot; class=&quot;headerlink&quot; title=&quot;录制宏&quot;&gt;&lt;/a&gt;录制宏&lt;/h1&gt;&lt;p&gt;用户录制的宏保存在寄存器中，我们先来看看什么是寄存器。vim的寄存器分为数字寄存器和字母寄存器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字寄存器为&lt;code&gt;0-9&lt;/code&gt;，&lt;code&gt;0&lt;/code&gt;保存着上次复制的内容，&lt;code&gt;1-9&lt;/code&gt;按照最近的顺序保存着最近删除的内容。&lt;/li&gt;
&lt;li&gt;字母寄存器为&lt;code&gt;a-z&lt;/code&gt;，拷贝3行到寄存器&lt;code&gt;c&lt;/code&gt;：&lt;code&gt;c3yy&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在开始录制宏。假如有如下的文件，我们希望将第二列的类型用&lt;code&gt;` &lt;/code&gt;分隔起来。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 | BOOL  | Boolean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 | SINT  | Short integer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 | INT   | Integer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 | DINT  | Double integer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 | LINT  | Long integer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6 | USINT | Unsigned short integer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7 | UINT  | Unsigned integer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;首先按几次&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;进入normal模式，光标移到第一行，开始录制并存入m寄存器&lt;code&gt;qm&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;光标到行首&lt;code&gt;^&lt;/code&gt;，到第二列词首&lt;code&gt;ww&lt;/code&gt;，进入插入模式&lt;code&gt;i&lt;/code&gt;，插入分隔符&lt;code&gt;` &lt;/code&gt;，退出到normal模式&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;，到词尾&lt;code&gt;e&lt;/code&gt;，进入插入模式&lt;code&gt;i&lt;/code&gt;，插入分隔符&lt;code&gt;` &lt;/code&gt;，退出到normal模式&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;，光标到下一行&lt;code&gt;j&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;结束录制&lt;code&gt;q&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;光标到第二行，在normal模式执行100次寄存器m中的宏&lt;code&gt;100@m&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;宏会在&lt;code&gt;j&lt;/code&gt;执行错误后自动结束，得到如下文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 | `BOOL`  | Boolean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 | `SINT`  | Short integer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 | `INT`   | Integer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 | `DINT`  | Double integer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 | `LINT`  | Long integer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6 | `USINT` | Unsigned short integer &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7 | `UINT`  | Unsigned integer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。&lt;br&gt;如果你还没有使用过Vim，建议你先去看这个：&lt;a href=&quot;!--￼4--&quot;&gt;Vim初级：配置和使用&lt;/a&gt;。本文介绍一些Vim的高级特性。包括块编辑、宏录制、语法高亮、键盘映射、函数定义、文件类型识别与对应插件加载等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;英文文档：&lt;a href=&quot;http://vimdoc.sourceforge.net/htmldoc/，中文文档：http://vimcdoc.sourceforge.net/doc/&quot;&gt;http://vimdoc.sourceforge.net/htmldoc/，中文文档：http://vimcdoc.sourceforge.net/doc/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;块编辑&quot;&gt;&lt;a href=&quot;#块编辑&quot; class=&quot;headerlink&quot; title=&quot;块编辑&quot;&gt;&lt;/a&gt;块编辑&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可视&lt;/strong&gt; 模式：&lt;code&gt;v&lt;/code&gt; 可进入visual模式，使用标准快捷键移动光标可选择文本块，之后可输入标准编辑命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;列编辑&lt;/strong&gt; 模式：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，移动光标将按列进行选中。例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;删除块注释：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，&lt;code&gt;ikjl&lt;/code&gt; 选中注释列，&lt;code&gt;&amp;lt;N&amp;gt;x&lt;/code&gt; 删除N个字符；&lt;/p&gt;
&lt;p&gt;添加块注释：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，&lt;code&gt;ikjl&lt;/code&gt; 选中要注释的行，&lt;code&gt;I&lt;/code&gt; 进入插入模式，输入几个注释字符，&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; 推出列编辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim所有的模式（即工作状态）如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(o) 普通模式: 输入命令时。&lt;/li&gt;
&lt;li&gt;(x) 可视模式: 可视区域高亮并输入命令时。&lt;/li&gt;
&lt;li&gt;(s) 选择模式: 类似于可视模式，但键入的字符对选择区进行替换。&lt;/li&gt;
&lt;li&gt;(o) 操作符等待模式: 操作符等待中 (“d”，”y”，”c” 等等之后)。&lt;/li&gt;
&lt;li&gt;(i) 插入模式: 也用于替换模式。&lt;/li&gt;
&lt;li&gt;(c) 命令行模式: 输入 “:” 或 “/“ 命令时。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;行尾块&lt;/strong&gt; ：因行尾参差不齐，块编辑一般用于行首、行间；行尾编辑要有一些技巧：&lt;code&gt;gg&lt;/code&gt;到文件头，&lt;code&gt;&amp;lt;Ctrl-v&amp;gt;&lt;/code&gt;进入块编辑模式，&lt;code&gt;G&lt;/code&gt;选择所有内容；&lt;code&gt;$A&lt;/code&gt;到行尾并进入插入模式，输入要插入的字符，&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt;完成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Bash Markdown Unix Vim 宏 寄存器 快捷键" scheme="http://yunvoo.com/tags/Bash-Markdown-Unix-Vim-%E5%AE%8F-%E5%AF%84%E5%AD%98%E5%99%A8-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>各种CSS选择器的优先级</title>
    <link href="http://yunvoo.com//blog/2015/07/16/css-priority.html"/>
    <id>http://yunvoo.com//blog/2015/07/16/css-priority.html</id>
    <published>2015-07-15T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.145Z</updated>
    
    <content type="html">&lt;p&gt;CSS规则之间可以互相覆盖，这一点我们应该已经习以为常了。然而正是由于规则之间可以互相覆盖、子元素继承父元素的默认行为，导致了CSS冲突的问题。&lt;br&gt;碰到CSS冲突时，通常我们会加入一些更加详细的规则来明确如何显示，以此解决冲突。通常越详细的规则优先级会越高，但优先级究竟是如何定义的呢？&lt;/p&gt;
&lt;p&gt;首先根据CSS定义位置来区别，优先级从低到高如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器默认样式（Browser Default Style）&lt;/li&gt;
&lt;li&gt;外部样式表&lt;/li&gt;
&lt;li&gt;内部样式表&lt;/li&gt;
&lt;li&gt;行内样式 (e.g., style=”font-weight:bold”)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样定义位置的规则，根据不同类型选择器的个数来确定。选择器的优先级从低到高如下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;F: Universal selectors (e.g., *)&lt;/li&gt;
&lt;li&gt;E: Type selectors (e.g., h1)&lt;/li&gt;
&lt;li&gt;D: Class selectors (e.g., .example)&lt;/li&gt;
&lt;li&gt;C: Attributes selectors (e.g., [type=”radio”])&lt;/li&gt;
&lt;li&gt;B: Pseudo-classes (e.g., :hover)&lt;/li&gt;
&lt;li&gt;A: ID selectors (e.g., #example)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;即 ID &amp;gt; 伪类 &amp;gt; 属性 &amp;gt; 类 &amp;gt; 元素 &amp;gt; 通配符，首先我们数规则中ID的个数，ID个数越多的规则优先级越高。如果相同，再数伪类，以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;来个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;article&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;span&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: blue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#red&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;article p span&lt;/code&gt;的优先级：”A=0, B=0, C=0, D=0, E=3, F=0 (000030)”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#red&lt;/code&gt;的优先级：”A=1, B=0, C=0, D=0, E=0, F=0 (100000)”（更高！）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再比如：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#wrapper&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;nav&lt;/span&gt; &lt;span class=&quot;selector-id&quot;&gt;#gnavi&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;list-style-type&lt;/span&gt;: none;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#top&lt;/span&gt; &lt;span class=&quot;selector-id&quot;&gt;#hright&lt;/span&gt; &lt;span class=&quot;selector-id&quot;&gt;#gnavi&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;list-style-type&lt;/span&gt;: square;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#wrapper header div nav #gnavi&lt;/code&gt;的优先级：”A=2, B=0, C=0, D=0, E=3, F=0 (200030)”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#top #hright #gnavi&lt;/code&gt;的优先级：”A=3, B=0, C=0, D=0, E=0, F=0 (300000)”（更高！）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，&lt;strong&gt;最高优先级的是&lt;code&gt;!import&lt;/code&gt;的属性&lt;/strong&gt;，如果都加了&lt;code&gt;!important&lt;/code&gt;那就继续数规则中属性和元素的个数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;能避免&lt;code&gt;!important&lt;/code&gt;的话就不要这样写了，这样的样式太难扩展了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考链接： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.w3.org/wiki/CSS/Training/Priority_level_of_selector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3.org/wiki/CSS/Training/Priority_level_of_selector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.hongkiat.com/blog/css-priority-level/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.hongkiat.com/blog/css-priority-level/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CSS规则之间可以互相覆盖，这一点我们应该已经习以为常了。然而正是由于规则之间可以互相覆盖、子元素继承父元素的默认行为，导致了CSS冲突的问题。&lt;br&gt;碰到CSS冲突时，通常我们会加入一些更加详细的规则来明确如何显示，以此解决冲突。通常越详细的规则优先级会越高，但优先级究竟是如何定义的呢？&lt;/p&gt;
&lt;p&gt;首先根据CSS定义位置来区别，优先级从低到高如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器默认样式（Browser Default Style）&lt;/li&gt;
&lt;li&gt;外部样式表&lt;/li&gt;
&lt;li&gt;内部样式表&lt;/li&gt;
&lt;li&gt;行内样式 (e.g., style=”font-weight:bold”)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样定义位置的规则，根据不同类型选择器的个数来确定。选择器的优先级从低到高如下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;F: Universal selectors (e.g., *)&lt;/li&gt;
&lt;li&gt;E: Type selectors (e.g., h1)&lt;/li&gt;
&lt;li&gt;D: Class selectors (e.g., .example)&lt;/li&gt;
&lt;li&gt;C: Attributes selectors (e.g., [type=”radio”])&lt;/li&gt;
&lt;li&gt;B: Pseudo-classes (e.g., :hover)&lt;/li&gt;
&lt;li&gt;A: ID selectors (e.g., #example)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;即 ID &amp;gt; 伪类 &amp;gt; 属性 &amp;gt; 类 &amp;gt; 元素 &amp;gt; 通配符，首先我们数规则中ID的个数，ID个数越多的规则优先级越高。如果相同，再数伪类，以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="CSS HTML 伪类 盒模型" scheme="http://yunvoo.com/tags/CSS-HTML-%E4%BC%AA%E7%B1%BB-%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++手稿：函数与参数</title>
    <link href="http://yunvoo.com//blog/2015/07/07/cpp-functions-and-arguments.html"/>
    <id>http://yunvoo.com//blog/2015/07/07/cpp-functions-and-arguments.html</id>
    <published>2015-07-06T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.150Z</updated>
    
    <content type="html">&lt;p&gt;本文就小编曾经遇到的函数及其参数问题，整理一篇博客在此。涉及到默认参数、函数重载、可变参数等方面。&lt;/p&gt;
&lt;h1 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h1&gt;&lt;p&gt;在函数声明中可以设置若干个默认参数，这些参数在函数调用时可以省略。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print();  &lt;span class=&quot;comment&quot;&gt;// 3 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 4 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// compile error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认参数提供了更灵活的函数声明。简化函数逻辑的同时，也提供了一种扩展既有函数的方式。&lt;/p&gt;
&lt;p&gt;在很多情况下，函数的声明与定义是分开的。语法上讲我们可以在声明时给出默认参数，&lt;br&gt;也可以在定义时给出默认参数。然而在函数调用处，编译器会进行语法检查，&lt;br&gt;被调用的“函数签名”是否存在、是否有歧义，只取决于调用处可见的那个函数（声明或定义）。&lt;/p&gt;
&lt;h1 id=&quot;函数重载&quot;&gt;&lt;a href=&quot;#函数重载&quot; class=&quot;headerlink&quot; title=&quot;函数重载&quot;&gt;&lt;/a&gt;函数重载&lt;/h1&gt;&lt;p&gt;C++中可以通过不同的参数个数来进行函数重载。唯一需要注意的是提供默认参数时，&lt;strong&gt;重载函数的调用会有二义性&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同时定义上述两个&lt;code&gt;print&lt;/code&gt;函数没有问题，因为它们的函数签名是不同的。但&lt;code&gt;print()&lt;/code&gt;的调用存在歧义，此处会发生编译错误。&lt;br&gt;因此，&lt;strong&gt;使用默认参数时，要避免函数重载的二义性&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除了虚函数外，函数调用的函数地址是在编译期决定的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;可变参数&quot;&gt;&lt;a href=&quot;#可变参数&quot; class=&quot;headerlink&quot; title=&quot;可变参数&quot;&gt;&lt;/a&gt;可变参数&lt;/h1&gt;&lt;p&gt;可变参数是指一个函数可以接受可变数目的参数，在C语言中最常见的便是&lt;code&gt;printf&lt;/code&gt;和&lt;code&gt;scanf&lt;/code&gt;。&lt;br&gt;它们是如何实现的呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然这不是函数重载，我们只定义一个函数，它可以接受任意个参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道函数调用前需要将参数压栈，默认情况下C++会将参数从右向左顺序压栈。&lt;br&gt;栈空间是从高地址向低地址生长的，故第一个参数拥有最低的地址。&lt;br&gt;获取第一个参数后，我们只要知道后续参数的类型和个数，就可以逐个按照地址取出来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在DLL生成和跨语言的过程调用时，常常遇到压栈顺序和由谁清空参数栈的问题，它们可以在函数声明中加入类似&lt;code&gt;_stdcall&lt;/code&gt;、&lt;code&gt;_cdecl&lt;/code&gt;等关键字来指定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何定义一个可变参数的函数？C++提供了&lt;a href=&quot;http://www.cplusplus.com/reference/cstdarg/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stdarg.h&lt;/a&gt;头文件，它定义了若干宏来方便上述的操作。&lt;br&gt;首先使用&lt;code&gt;va_list&lt;/code&gt;来获取参数栈，&lt;code&gt;va_start&lt;/code&gt;来指定第一个参数的地址。&lt;br&gt;此后便可以使用&lt;code&gt;va_arg()&lt;/code&gt;来获取后续的参数了，这时需要指定类型（因为需要确定空间大小）。&lt;br&gt;最后用&lt;code&gt;va_end&lt;/code&gt;来释放资源。一个简单的可变参数的函数像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdarg.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;my_print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count, ...)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    va_list ap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    va_start(ap, count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j&amp;lt;count; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;va_arg(ap, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;)&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    va_end(ap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;第一个参数是必不可少的，我们需要用它来确定参数的个数。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文就小编曾经遇到的函数及其参数问题，整理一篇博客在此。涉及到默认参数、函数重载、可变参数等方面。&lt;/p&gt;
&lt;h1 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h1&gt;&lt;p&gt;在函数声明
    
    </summary>
    
    
      <category term="C++ 宏 编译 函数重载 可变参数 过程调用 默认参数 DLL 栈空间" scheme="http://yunvoo.com/tags/C-%E5%AE%8F-%E7%BC%96%E8%AF%91-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0-DLL-%E6%A0%88%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>C++手稿：指针与引用</title>
    <link href="http://yunvoo.com//blog/2015/07/05/cpp-pointers-and-references.html"/>
    <id>http://yunvoo.com//blog/2015/07/05/cpp-pointers-and-references.html</id>
    <published>2015-07-04T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.155Z</updated>
    
    <content type="html">&lt;p&gt;C++的引用和指针始终是最容易出错的地方，大量的C++错误都是由空引用和空指针造成的。&lt;br&gt;与此同时，常量指针、函数指针、数组指针也是容易产生困惑的地方。&lt;br&gt;本文便来总结一下C++中引用和指针的用法，以及智能指针的概念。&lt;/p&gt;
&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;p&gt;引用是C++的C语言的扩充，用来定义一个变量的别名。其使用方式同被引用的变量，且可以通过参数传递引用。&lt;br&gt;引用在定义时必须初始化为一个变量，初始化为常量或表达式都会引发编译错误。&lt;/p&gt;
&lt;p&gt;引用是一种隐式的指针，对它的操作都会被解释为对它引用的对象的操作。&lt;br&gt;引用不占用栈空间，因为编译器知道它的地址。但作为参数传递引用时，会把指针放在参数栈中。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;amp; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     x = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;amp; j = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     function(j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 其中&lt;code&gt;j&lt;/code&gt;并不占用当前的栈空间，而&lt;code&gt;function&lt;/code&gt;被调用前会将&lt;code&gt;j&lt;/code&gt;的地址放入它的参数栈中。&lt;/p&gt;
&lt;p&gt; 关于引用的内存占用： &lt;a href=&quot;http://stackoverflow.com/questions/1179937/how-does-a-c-reference-look-memory-wise&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/1179937/how-does-a-c-reference-look-memory-wise&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;引用参数&quot;&gt;&lt;a href=&quot;#引用参数&quot; class=&quot;headerlink&quot; title=&quot;引用参数&quot;&gt;&lt;/a&gt;引用参数&lt;/h1&gt;&lt;p&gt;为了在函数中修改传入的参数，可以把函数参数声明为引用。一个经典的使用场景是&lt;code&gt;swap&lt;/code&gt;，避免了繁琐的指针操作：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;amp; lhs, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;amp; rhs)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp = lhs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lhs = rhs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rhs = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swap(a, b);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;传引用还是传值，对于调用者来讲是没有区别的。这一点与传指针是不同的，如果要传递指针调用者需要先对参数变量取地址。&lt;/p&gt;
&lt;h1 id=&quot;引用返回值&quot;&gt;&lt;a href=&quot;#引用返回值&quot; class=&quot;headerlink&quot; title=&quot;引用返回值&quot;&gt;&lt;/a&gt;引用返回值&lt;/h1&gt;&lt;p&gt;引用作为函数的返回值，一般是为了在函数外部修改内部变量。例如，对下标操作符的重载：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Array&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[N] &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;[](i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Array arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如果返回值为&lt;code&gt;int&lt;/code&gt;而非&lt;code&gt;int&amp;amp;&lt;/code&gt;，则运行时会将&lt;code&gt;array[i]&lt;/code&gt;拷贝一份作为返回值，此时赋值无效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;常量指针与指针常量&quot;&gt;&lt;a href=&quot;#常量指针与指针常量&quot; class=&quot;headerlink&quot; title=&quot;常量指针与指针常量&quot;&gt;&lt;/a&gt;常量指针与指针常量&lt;/h1&gt;&lt;p&gt;常量指针指向地方的内容不可改变，指针常量指向的地方不可改变。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义整数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, m=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 常量指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * p = &amp;amp;n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*p = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;// 编译错&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 指针常量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p = &amp;amp;n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p = &amp;amp;m;   &lt;span class=&quot;comment&quot;&gt;// 编译错&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 指针和指向的对象都是常量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p = &amp;amp;n;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;通常来讲，编译器允许变量到常量的隐式转换，不允许常量到变量的转换。可以参考&lt;code&gt;const_cast&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;指针数组&quot;&gt;&lt;a href=&quot;#指针数组&quot; class=&quot;headerlink&quot; title=&quot;指针数组&quot;&gt;&lt;/a&gt;指针数组&lt;/h1&gt;&lt;p&gt;指针数组是有一系列指针构成的数组，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* arr[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数组的长度为8，数组的每一项都是类型为&lt;code&gt;int*&lt;/code&gt;的指针。&lt;/p&gt;
&lt;h1 id=&quot;数组指针&quot;&gt;&lt;a href=&quot;#数组指针&quot; class=&quot;headerlink&quot; title=&quot;数组指针&quot;&gt;&lt;/a&gt;数组指针&lt;/h1&gt;&lt;p&gt;数组指针是指向数组的指针，在C++中可以声明一个指向长度为8的数组的指针：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (*arr)[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;函数指针&quot;&gt;&lt;a href=&quot;#函数指针&quot; class=&quot;headerlink&quot; title=&quot;函数指针&quot;&gt;&lt;/a&gt;函数指针&lt;/h1&gt;&lt;p&gt;函数指针通常用来进行传参，借此实现动态的策略。传参时可以用函数名，也可以用函数指针。而函数指针需要用函数名来初始化。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int sum(int a, int b)j&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void wrapper(int a, int b, int (*p)(int, int))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;p(a, b)&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wrapper(2, 3, sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int (*p)(int, int) = sum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    wrapper(2, 3, p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类似地，函数指针也可以组成一个数组：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (*p[])(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) = &amp;#123;sum, sum&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wrapper(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, p[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wrapper(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, p[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了函数指针，函数对象也常用来传递动态的策略。&lt;br&gt;它们有一致的调用方式，在类模板中具有相同的隐式接口，&lt;br&gt;因此多数STL算法模板都可以不加区分地使用函数对象或者函数指针，&lt;br&gt;详情见&lt;a href=&quot;/2015/08/23/effective-cpp-41.html&quot;&gt;Effective C++: Item 41&lt;/a&gt;）。&lt;/p&gt;
&lt;h1 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;!--￼9--&quot;&gt;Effective C++: Item 13&lt;/a&gt;中详细介绍了智能指针的概念与使用方法。&lt;/p&gt;
&lt;p&gt;C++没有内置的垃圾回收机制，所以获取和回收资源需要程序员来设计。&lt;br&gt;使用new构造的对象，如果将删除它的责任给调用者，将很容易发生疏漏，尤其是控制流发生改变时。&lt;br&gt;我们可以想到让对象来管理资源，利用会被自动调用的析构函数来完成资源的回收。&lt;br&gt;STL中已经提供了这样一个类模板：&lt;code&gt;std::auto_ptr&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;auto_ptr&lt;/span&gt;&amp;lt;Investment&amp;gt; invest()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;auto_ptr&lt;/span&gt;&amp;lt;Investment&amp;gt; pInv(createInvestment());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;code&gt;auto_ptr&lt;/code&gt;析构函数中使用的是&lt;code&gt;delete&lt;/code&gt;而非&lt;code&gt;delete[]&lt;/code&gt;，所以不适合管理数组资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时，&lt;code&gt;auto_ptr&lt;/code&gt;重载了赋值运算符，保证了资源不会被多次析构。&lt;br&gt;这样，&lt;code&gt;auto_ptr&lt;/code&gt;的赋值操作会转移资源，原指针将会变为&lt;code&gt;NULL&lt;/code&gt;.&lt;br&gt;如果需要同时存在多个引用，可以使用&lt;code&gt;shared_ptr&lt;/code&gt;，它会对引用进行计数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;的引用计数很像垃圾回收，然而它并不能解决环状引用的问题。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;C++的引用和指针始终是最容易出错的地方，大量的C++错误都是由空引用和空指针造成的。&lt;br&gt;与此同时，常量指针、函数指针、数组指针也是容易产生困惑的地方。&lt;br&gt;本文便来总结一下C++中引用和指针的用法，以及智能指针的概念。&lt;/p&gt;
&lt;h1 id=&quot;引用&quot;&gt;&lt;a href
    
    </summary>
    
    
      <category term="C++ STL 内存 引用 指针 数组 函数指针 智能指针 析构函数 栈空间" scheme="http://yunvoo.com/tags/C-STL-%E5%86%85%E5%AD%98-%E5%BC%95%E7%94%A8-%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E6%A0%88%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>C++手稿：STL中的函数对象与函数指针</title>
    <link href="http://yunvoo.com//blog/2015/07/03/stl-function-objects-and-pointers.html"/>
    <id>http://yunvoo.com//blog/2015/07/03/stl-function-objects-and-pointers.html</id>
    <published>2015-07-02T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.159Z</updated>
    
    <content type="html">&lt;p&gt;STL是C++的标准模板库（standard template library），自然其中定义的都是模板。&lt;br&gt;相比于类和函数声明的&lt;strong&gt;显式接口（explicit interface）&lt;/strong&gt;，类模板和函数模板声明的接口属于&lt;strong&gt;隐式接口（implicit interface）&lt;/strong&gt;。&lt;br&gt;因为模板参数应当满足的接口是由模板中表达式的合法性决定的，这一点给了模板很大的自由。&lt;br&gt;而&lt;em&gt;函数对象&lt;/em&gt;和&lt;em&gt;函数指针&lt;/em&gt;具有同样的调用语法，因此STL中这两者常常可以互换。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更多关于隐式接口和显式接口的概念和区别，参见&lt;a href=&quot;/2015/09/08/effective-cpp-41.html&quot;&gt;Effective C++: Item 41&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来感受一下C++中的函数对象和函数指针：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b, T func)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;func(a, b)&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在STL中定义了很多像上面这样的模板，这里的T是一个可调用（实现了括号运算符）的东西。&lt;br&gt;这使得我们在使用模板时可以指定一个计算策略，它可以是函数对象，也可以是函数指针。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Less&amp;lt;int&amp;gt;&lt;/code&gt;便是一个常见的函数对象，常用来配置容器或算法。&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;中定义了很多这样的函数对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;函数指针&quot;&gt;&lt;a href=&quot;#函数指针&quot; class=&quot;headerlink&quot; title=&quot;函数指针&quot;&gt;&lt;/a&gt;函数指针&lt;/h1&gt;&lt;p&gt;函数指针通常用来将函数传参或存储。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printer(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述的&lt;code&gt;printer&lt;/code&gt;调用方式，编译器会生成对应的函数实例：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void printer(int a, int b, int (*func)(int, int))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;func(a, b)&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;T&lt;/code&gt;的类型是&lt;code&gt;int (*)(int, int)&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是python或者javascript程序员的话，上述过程没有什么特别的。&lt;br&gt;唯一要注意的是&lt;code&gt;func&lt;/code&gt;的声明方式，星号要和标识符括起来：&lt;code&gt;(*func)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;函数对象&quot;&gt;&lt;a href=&quot;#函数对象&quot; class=&quot;headerlink&quot; title=&quot;函数对象&quot;&gt;&lt;/a&gt;函数对象&lt;/h1&gt;&lt;p&gt;函数对象是重载了括号运算符的类的实例，它也可以这样调用：&lt;code&gt;func(a, b)&lt;/code&gt;。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Sum&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printer(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, Sum());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编译器会生成这样的函数实例：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b, Sum s)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;s(a, b)&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;函数对象可以实现更加复杂的有状态的运算，因为对象可以有更多的属性和方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;std-accumulate&quot;&gt;&lt;a href=&quot;#std-accumulate&quot; class=&quot;headerlink&quot; title=&quot;std::accumulate&quot;&gt;&lt;/a&gt;std::accumulate&lt;/h1&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;// std::cout&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;functional&amp;gt;&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;// std::minus&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;numeric&amp;gt;&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;// std::accumulate&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myfunction&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x+&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*y;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; myclass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*y;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; myobject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; init = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numbers[] = &amp;#123;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::accumulate(numbers,numbers+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,init) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::accumulate (numbers, numbers+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, init, &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::minus&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;()) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::accumulate (numbers, numbers+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, init, myfunction) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::accumulate (numbers, numbers+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, init, myobject) &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里&lt;code&gt;accumulate&lt;/code&gt;的第四个参数默认值为&lt;code&gt;std::plus&amp;lt;int&amp;gt;()&lt;/code&gt;，是一个函数对象，&lt;br&gt;&lt;code&gt;std::minus&amp;lt;int&amp;gt;()&lt;/code&gt;也是一个函数对象，它们都是在&lt;code&gt;functional&lt;/code&gt;中定义的。&lt;br&gt;&lt;code&gt;myfunction&lt;/code&gt;是函数指针，而&lt;code&gt;myobject&lt;/code&gt;是自定义的函数对象。输出如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;220&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;280&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;摘自cplusplus.com： &lt;a href=&quot;http://www.cplusplus.com/reference/numeric/accumulate&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cplusplus.com/reference/numeric/accumulate&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;比较器：std-sort&quot;&gt;&lt;a href=&quot;#比较器：std-sort&quot; class=&quot;headerlink&quot; title=&quot;比较器：std::sort&quot;&gt;&lt;/a&gt;比较器：std::sort&lt;/h1&gt;&lt;p&gt;需要比较元素大小的STL算法、容器的模板、容器的成员函数，都可以给定一个比较策略。它们的默认值通常是&lt;code&gt;Less&amp;lt;T&amp;gt;()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，指定&lt;code&gt;greater&lt;/code&gt;函数对象作为比较器，就可以实现反向排序：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sort(v.begin(), v.end(), greater&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;std::sort&lt;/code&gt;要求随机存取迭代器，&lt;code&gt;list&lt;/code&gt;不可用&lt;code&gt;std::sort&lt;/code&gt;，可以使用&lt;code&gt;list::sort(Pred pr)&lt;/code&gt;。&lt;br&gt;&lt;code&gt;std::sort&lt;/code&gt;实际上是快排，复杂度为$O(n lgn)$，它是不稳定的。&lt;code&gt;stale_sort&lt;/code&gt;则是稳定的归并排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;比较器：模板参数&quot;&gt;&lt;a href=&quot;#比较器：模板参数&quot; class=&quot;headerlink&quot; title=&quot;比较器：模板参数&quot;&gt;&lt;/a&gt;比较器：模板参数&lt;/h1&gt;&lt;p&gt;关联容器通常使用搜索树来实现，所以插入元素时需要进行比较操作。&lt;br&gt;我们在使用容器模板时可以指定比较器：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; A&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; _n):n(_n)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;&amp;lt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; lhs, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; rhs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lhs.n &amp;lt; rhs.n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;multiset&lt;/span&gt;&amp;lt;A, less&amp;lt;A&amp;gt;&amp;gt; s;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.insert(A());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认情况下关联容器使用&lt;code&gt;less&lt;/code&gt;模板来进行元素比较，而&lt;code&gt;less&lt;/code&gt;中调用了&lt;code&gt;&amp;lt;&lt;/code&gt;，&lt;br&gt;所以默认情况下插入关联容器的元素需要实现&lt;code&gt;&amp;lt;&lt;/code&gt;运算符：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果未实现相应的比较运算符，&lt;code&gt;insert&lt;/code&gt;操作会编译错。因为运算符调用本质上是函数调用。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;STL是C++的标准模板库（standard template library），自然其中定义的都是模板。&lt;br&gt;相比于类和函数声明的&lt;strong&gt;显式接口（explicit interface）&lt;/strong&gt;，类模板和函数模板声明的接口属于&lt;strong&gt;隐式接口（implicit interface）&lt;/strong&gt;。&lt;br&gt;因为模板参数应当满足的接口是由模板中表达式的合法性决定的，这一点给了模板很大的自由。&lt;br&gt;而&lt;em&gt;函数对象&lt;/em&gt;和&lt;em&gt;函数指针&lt;/em&gt;具有同样的调用语法，因此STL中这两者常常可以互换。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;更多关于隐式接口和显式接口的概念和区别，参见&lt;a href=&quot;/2015/09/08/effective-cpp-41.html&quot;&gt;Effective C++: Item 41&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来感受一下C++中的函数对象和函数指针：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b, T func)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;func(a, b)&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在STL中定义了很多像上面这样的模板，这里的T是一个可调用（实现了括号运算符）的东西。&lt;br&gt;这使得我们在使用模板时可以指定一个计算策略，它可以是函数对象，也可以是函数指针。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Less&amp;lt;int&amp;gt;&lt;/code&gt;便是一个常见的函数对象，常用来配置容器或算法。&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;中定义了很多这样的函数对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;函数指针&quot;&gt;&lt;a href=&quot;#函数指针&quot; class=&quot;headerlink&quot; title=&quot;函数指针&quot;&gt;&lt;/a&gt;函数指针&lt;/h1&gt;&lt;p&gt;函数指针通常用来将函数传参或存储。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printer(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, sum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述的&lt;code&gt;printer&lt;/code&gt;调用方式，编译器会生成对应的函数实例：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void printer(int a, int b, int (*func)(int, int))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cout&amp;lt;&amp;lt;func(a, b)&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里&lt;code&gt;T&lt;/code&gt;的类型是&lt;code&gt;int (*)(int, int)&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你是python或者javascript程序员的话，上述过程没有什么特别的。&lt;br&gt;唯一要注意的是&lt;code&gt;func&lt;/code&gt;的声明方式，星号要和标识符括起来：&lt;code&gt;(*func)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;函数对象&quot;&gt;&lt;a href=&quot;#函数对象&quot; class=&quot;headerlink&quot; title=&quot;函数对象&quot;&gt;&lt;/a&gt;函数对象&lt;/h1&gt;&lt;p&gt;函数对象是重载了括号运算符的类的实例，它也可以这样调用：&lt;code&gt;func(a, b)&lt;/code&gt;。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Sum&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printer(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, Sum());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编译器会生成这样的函数实例：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b, Sum s)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;s(a, b)&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;函数对象可以实现更加复杂的有状态的运算，因为对象可以有更多的属性和方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="C++ STL 指针 模板 运算符 函数对象 函数指针" scheme="http://yunvoo.com/tags/C-STL-%E6%8C%87%E9%92%88-%E6%A8%A1%E6%9D%BF-%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++手稿：STL小记</title>
    <link href="http://yunvoo.com//blog/2015/07/01/introduction-to-stl.html"/>
    <id>http://yunvoo.com//blog/2015/07/01/introduction-to-stl.html</id>
    <published>2015-06-30T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.164Z</updated>
    
    <content type="html">&lt;p&gt;STL (Standard Template Library) 提供了一些常用的数据结构和算法的模板，1998年加入C++标准。&lt;br&gt;STL中有三个重要的概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器：容纳各种数据类型的数据结构，是一系列的类模板。&lt;/li&gt;
&lt;li&gt;迭代器：迭代器用来迭代地访问容器中的元素。&lt;/li&gt;
&lt;li&gt;算法：用来操作容器中的元素，是一系列的函数模板。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;STL-容器&quot;&gt;&lt;a href=&quot;#STL-容器&quot; class=&quot;headerlink&quot; title=&quot;STL 容器&quot;&gt;&lt;/a&gt;STL 容器&lt;/h1&gt;&lt;p&gt;STL中的容器定义在&lt;code&gt;std&lt;/code&gt;命名空间下，需要引入头文件&lt;br&gt;&lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stack&amp;gt;&lt;/code&gt;&lt;br&gt;等。容器可以分为三大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序容器&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/vector/vector&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vector&lt;/a&gt;：尾端插入元素有较高性能，动态数组实现；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/deque/deque/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;deque&lt;/a&gt;：收尾插入元素都有较高性能，动态数组实现；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/list/list/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;list&lt;/a&gt;：可以常数时间在任何地方插入元素，链表实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关联容器&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/set/set&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;set&lt;/a&gt;：不同元素的集合，平衡二叉树实现，检索时间是 $O(log(N))$；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/set/multiset&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;multiset&lt;/a&gt;：同上，但可以包含相同元数据；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/map/map&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;map&lt;/a&gt;：同&lt;code&gt;set&lt;/code&gt;，但存放的是键值对；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/map/multimap/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;multimap&lt;/a&gt;：同上，键可以重复；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容器适配器：&lt;a href=&quot;http://www.cplusplus.com/reference/stack/stack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stack&lt;/a&gt;，&lt;a href=&quot;http://www.cplusplus.com/reference/queue/queue&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;queue&lt;/a&gt;，&lt;a href=&quot;http://www.cplusplus.com/reference/queue/priority_queue/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;priority_queue&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些容器有一些通用的方法：&lt;code&gt;empty&lt;/code&gt;，&lt;code&gt;size&lt;/code&gt;，&lt;code&gt;swap&lt;/code&gt;，&lt;code&gt;max_size&lt;/code&gt;。前两类容器支持迭代器，称为第一类容器。&lt;br&gt;顺序容器还有以下通用方法：&lt;code&gt;front&lt;/code&gt;, &lt;code&gt;back&lt;/code&gt;, &lt;code&gt;pop_back&lt;/code&gt;, &lt;code&gt;push_back&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;容器之间的比较取决于第一个不等的元素；如果长度相同且所有元素相等，两个容器相等；如果一个是另一个的子序列，则较短的容器小于较长的容器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;存储键值对关联容器&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;multimap&lt;/code&gt;的迭代器是一个&lt;code&gt;pair&amp;lt;T1, T2&amp;gt;&lt;/code&gt;的指针。&lt;br&gt;插入时，可以使用&lt;code&gt;[]&lt;/code&gt;运算符，也可以使用&lt;code&gt;insert&lt;/code&gt;方法，它接受一个&lt;code&gt;pair&amp;lt;T1, T2&amp;gt;&lt;/code&gt;对象：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; mymap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap.insert (mymap.begin(), &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::pair&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;400&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap.insert (mymap.begin(), &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::make_pair(&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;400&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;pair&lt;/code&gt;模板类在&lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;中定义，在&lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;中已经引入了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容器适配器是逻辑数据结构，需要用一种顺序容器来实现。例如，&lt;code&gt;stack&lt;/code&gt;默认使用&lt;code&gt;deque&lt;/code&gt;来实现，我们也可以指定它的实现方式。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt; strstk;         &lt;span class=&quot;comment&quot;&gt;// string 型栈，deque实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; stk;  &lt;span class=&quot;comment&quot;&gt;// int 型栈，vector实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;STL-迭代器&quot;&gt;&lt;a href=&quot;#STL-迭代器&quot; class=&quot;headerlink&quot; title=&quot;STL 迭代器&quot;&gt;&lt;/a&gt;STL 迭代器&lt;/h1&gt;&lt;p&gt;只有第一类容器支持迭代器（容器适配器不支持迭代器）。来个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::reverse_iterator r = v.rbegin(); r &amp;lt; v.rend(); r++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;*r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;取决于不同的存储方式，不同容器支持的迭代器是不同的。这些迭代器按功能的强弱分为5类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Input Iterator：提供只读访问&lt;/li&gt;
&lt;li&gt;Output Iterator：提供只写访问&lt;/li&gt;
&lt;li&gt;Forward Iterator：支持逐个向后迭代访问&lt;/li&gt;
&lt;li&gt;Bidirectional Iterator：能够双向地逐个迭代访问&lt;/li&gt;
&lt;li&gt;Random Access Iterator：可随机访问每个元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，双向迭代器不支持&lt;code&gt;&amp;lt;&lt;/code&gt;，&lt;code&gt;&amp;gt;&lt;/code&gt;，&lt;code&gt;[]&lt;/code&gt;运算符，只能判等：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; l;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::const_iterator i = l.begin(); i != l.end(); ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;*i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;支持Random Access Iterator，&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;set/multiset&lt;/code&gt;、&lt;code&gt;map/multimap&lt;/code&gt;支持Bidirectional Iterator。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;STL-算法&quot;&gt;&lt;a href=&quot;#STL-算法&quot; class=&quot;headerlink&quot; title=&quot;STL 算法&quot;&gt;&lt;/a&gt;STL 算法&lt;/h1&gt;&lt;p&gt;STL通过函数模板提供了很多作用于容器的通用算法，例如查找、插入、删除、排序等，需要引入头文件&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;变化序列的：&lt;code&gt;copy&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;fill&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;swap&lt;/code&gt;, …；不变化序列的：&lt;code&gt;find&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;for_each&lt;/code&gt;, &lt;code&gt;equal&lt;/code&gt;, …&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这些算法的实现较为通用，也可以作用于C语言的数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如，&lt;code&gt;find&lt;/code&gt;用值来搜索一个元素的迭代器：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v.push_back(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v.push_back(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v.push_back(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator p = find(v.begin(), v.end(), &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p != v.end()) &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;*p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如，&lt;code&gt;copy&lt;/code&gt;用来做容器之间的拷贝：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ostream_iterator&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; output(&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;copy(v.begin(), v.end(), output);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1 2 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如，&lt;code&gt;erase&lt;/code&gt;用来删除一个区间的元素：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;v.erase(v.begin(), v.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等效于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;v.clear();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如，&lt;code&gt;lower_bound(FwdIt f, FwdIt l, const T&amp;amp; val)&lt;/code&gt;用来给出小于&lt;code&gt;val&lt;/code&gt;的坐标上限（前闭后开）。&lt;br&gt;&lt;code&gt;upper_bound(FwdIt f, FwdIt l, const T&amp;amp; val)&lt;/code&gt;用来给出大于&lt;code&gt;val&lt;/code&gt;的坐标下限（前闭后开）：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; mymap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::iterator itlow,itup;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap[&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;]=&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap[&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;]=&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap[&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;]=&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap[&lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;]=&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap[&lt;span class=&quot;string&quot;&gt;&#39;e&#39;&lt;/span&gt;]=&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;itlow=mymap.lower_bound (&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// itlow points to b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;itup=mymap.upper_bound (&lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;);   &lt;span class=&quot;comment&quot;&gt;// itup points to e (not d!)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参见： &lt;a href=&quot;http://www.cplusplus.com/reference/map/map/upper_bound/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cplusplus.com/reference/map/map/upper_bound/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;实现一个Iterator&quot;&gt;&lt;a href=&quot;#实现一个Iterator&quot; class=&quot;headerlink&quot; title=&quot;实现一个Iterator&quot;&gt;&lt;/a&gt;实现一个Iterator&lt;/h1&gt;&lt;p&gt;为了实现上述&lt;code&gt;ostream_iterator&lt;/code&gt;，需要了解&lt;code&gt;copy&lt;/code&gt;的实现方式：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _II, &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; _OI&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; _&lt;span class=&quot;function&quot;&gt;OI &lt;span class=&quot;title&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(_II _F, _II _L, _OI _X)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;_F != _L; ++_X, ++_F)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *_X = *_F;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (_X);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因此&lt;code&gt;ostream_iterator&lt;/code&gt;需要重载&lt;code&gt;++&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;和&lt;code&gt;=&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;template&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; ostream_iterator&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; sep;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ostream&amp;amp; o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ostream_iterator(ostream&amp;amp; _o, &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; _s):o(_o), sep(_s)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ostream_iterator&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; T&amp;amp; v)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        o&amp;lt;&amp;lt;v&amp;lt;&amp;lt;sep; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ostream_iterator&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;*()&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ostream_iterator&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;++()&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;STL (Standard Template Library) 提供了一些常用的数据结构和算法的模板，1998年加入C++标准。&lt;br&gt;STL中有三个重要的概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器：容纳各种数据类型的数据结构，是一系列的类模板。&lt;/li&gt;
&lt;li&gt;迭代器：迭代器用来迭代地访问容器中的元素。&lt;/li&gt;
&lt;li&gt;算法：用来操作容器中的元素，是一系列的函数模板。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;STL-容器&quot;&gt;&lt;a href=&quot;#STL-容器&quot; class=&quot;headerlink&quot; title=&quot;STL 容器&quot;&gt;&lt;/a&gt;STL 容器&lt;/h1&gt;&lt;p&gt;STL中的容器定义在&lt;code&gt;std&lt;/code&gt;命名空间下，需要引入头文件&lt;br&gt;&lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stack&amp;gt;&lt;/code&gt;&lt;br&gt;等。容器可以分为三大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序容器&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/vector/vector&quot;&gt;vector&lt;/a&gt;：尾端插入元素有较高性能，动态数组实现；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/deque/deque/&quot;&gt;deque&lt;/a&gt;：收尾插入元素都有较高性能，动态数组实现；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/list/list/&quot;&gt;list&lt;/a&gt;：可以常数时间在任何地方插入元素，链表实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关联容器&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/set/set&quot;&gt;set&lt;/a&gt;：不同元素的集合，平衡二叉树实现，检索时间是 $O(log(N))$；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/set/multiset&quot;&gt;multiset&lt;/a&gt;：同上，但可以包含相同元数据；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/map/map&quot;&gt;map&lt;/a&gt;：同&lt;code&gt;set&lt;/code&gt;，但存放的是键值对；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/map/multimap/&quot;&gt;multimap&lt;/a&gt;：同上，键可以重复；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容器适配器：&lt;a href=&quot;http://www.cplusplus.com/reference/stack/stack&quot;&gt;stack&lt;/a&gt;，&lt;a href=&quot;http://www.cplusplus.com/reference/queue/queue&quot;&gt;queue&lt;/a&gt;，&lt;a href=&quot;http://www.cplusplus.com/reference/queue/priority_queue/&quot;&gt;priority_queue&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些容器有一些通用的方法：&lt;code&gt;empty&lt;/code&gt;，&lt;code&gt;size&lt;/code&gt;，&lt;code&gt;swap&lt;/code&gt;，&lt;code&gt;max_size&lt;/code&gt;。前两类容器支持迭代器，称为第一类容器。&lt;br&gt;顺序容器还有以下通用方法：&lt;code&gt;front&lt;/code&gt;, &lt;code&gt;back&lt;/code&gt;, &lt;code&gt;pop_back&lt;/code&gt;, &lt;code&gt;push_back&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;容器之间的比较取决于第一个不等的元素；如果长度相同且所有元素相等，两个容器相等；如果一个是另一个的子序列，则较短的容器小于较长的容器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;存储键值对关联容器&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;multimap&lt;/code&gt;的迭代器是一个&lt;code&gt;pair&amp;lt;T1, T2&amp;gt;&lt;/code&gt;的指针。&lt;br&gt;插入时，可以使用&lt;code&gt;[]&lt;/code&gt;运算符，也可以使用&lt;code&gt;insert&lt;/code&gt;方法，它接受一个&lt;code&gt;pair&amp;lt;T1, T2&amp;gt;&lt;/code&gt;对象：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; mymap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap.insert (mymap.begin(), &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::pair&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;(&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;400&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mymap.insert (mymap.begin(), &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::make_pair(&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;400&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;pair&lt;/code&gt;模板类在&lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;中定义，在&lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;中已经引入了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;容器适配器是逻辑数据结构，需要用一种顺序容器来实现。例如，&lt;code&gt;stack&lt;/code&gt;默认使用&lt;code&gt;deque&lt;/code&gt;来实现，我们也可以指定它的实现方式。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt; strstk;         &lt;span class=&quot;comment&quot;&gt;// string 型栈，deque实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt; stk;  &lt;span class=&quot;comment&quot;&gt;// int 型栈，vector实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;STL-迭代器&quot;&gt;&lt;a href=&quot;#STL-迭代器&quot; class=&quot;headerlink&quot; title=&quot;STL 迭代器&quot;&gt;&lt;/a&gt;STL 迭代器&lt;/h1&gt;&lt;p&gt;只有第一类容器支持迭代器（容器适配器不支持迭代器）。来个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; v;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::reverse_iterator r = v.rbegin(); r &amp;lt; v.rend(); r++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;*r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;取决于不同的存储方式，不同容器支持的迭代器是不同的。这些迭代器按功能的强弱分为5类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Input Iterator：提供只读访问&lt;/li&gt;
&lt;li&gt;Output Iterator：提供只写访问&lt;/li&gt;
&lt;li&gt;Forward Iterator：支持逐个向后迭代访问&lt;/li&gt;
&lt;li&gt;Bidirectional Iterator：能够双向地逐个迭代访问&lt;/li&gt;
&lt;li&gt;Random Access Iterator：可随机访问每个元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，双向迭代器不支持&lt;code&gt;&amp;lt;&lt;/code&gt;，&lt;code&gt;&amp;gt;&lt;/code&gt;，&lt;code&gt;[]&lt;/code&gt;运算符，只能判等：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; l;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt;::const_iterator i = l.begin(); i != l.end(); ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;*i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;支持Random Access Iterator，&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;set/multiset&lt;/code&gt;、&lt;code&gt;map/multimap&lt;/code&gt;支持Bidirectional Iterator。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ STL 栈 容器 排序 数组 模板 算法 链表 集合 二叉树 运算符 迭代器 平衡二叉树" scheme="http://yunvoo.com/tags/C-STL-%E6%A0%88-%E5%AE%B9%E5%99%A8-%E6%8E%92%E5%BA%8F-%E6%95%B0%E7%BB%84-%E6%A8%A1%E6%9D%BF-%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8-%E9%9B%86%E5%90%88-%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BF%90%E7%AE%97%E7%AC%A6-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>C++手稿：std::string</title>
    <link href="http://yunvoo.com//blog/2015/06/30/std-string.html"/>
    <id>http://yunvoo.com//blog/2015/06/30/std-string.html</id>
    <published>2015-06-29T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.169Z</updated>
    
    <content type="html">&lt;p&gt;字符串在很多编程语言中已经成为基本数据类型，C语言中我们使用&lt;code&gt;char*&lt;/code&gt;来手动维护字符串的内存，&lt;br&gt;在C++中，可以使用&lt;code&gt;std::string&lt;/code&gt;来方便地创建和操作字符串。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;是一个模板类，它有&lt;code&gt;basic_string&amp;lt;T&amp;gt;&lt;/code&gt;定义：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; basic_string&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;C++的&lt;code&gt;string&lt;/code&gt;可以通过成员方法&lt;code&gt;c_str()&lt;/code&gt;转换为C语言的&lt;code&gt;char*&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;http://www.cplusplus.com/reference/string/string/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cplusplus.com/string&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;初始化与赋值&quot;&gt;&lt;a href=&quot;#初始化与赋值&quot; class=&quot;headerlink&quot; title=&quot;初始化与赋值&quot;&gt;&lt;/a&gt;初始化与赋值&lt;/h1&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;有两个常用的构造函数：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 用一个C字符串构造&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等价于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以用N个同样的字符来构造字符串：&lt;code&gt;string str2(8, &amp;#39;x&amp;#39;)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在C0x标准中，&lt;code&gt;std::to_string&lt;/code&gt;可以将很多类型转换为一个&lt;code&gt;string&lt;/code&gt;，可以代替&lt;code&gt;itoa&lt;/code&gt;，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; str = to_string(&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;构造函数不接受&lt;code&gt;char&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字符串可以直接互相赋值，内存会自动拷贝和销毁，我们大可不必管它。对于单个字符赋值可以使用下标运算符：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;str.length(); i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str[i] = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;与多数class类似，&lt;code&gt;string&lt;/code&gt;也提供了&lt;code&gt;swap&lt;/code&gt;：&lt;code&gt;str1.swap(s2)&lt;/code&gt;将会交换二者的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;运算符支持&quot;&gt;&lt;a href=&quot;#运算符支持&quot; class=&quot;headerlink&quot; title=&quot;运算符支持&quot;&gt;&lt;/a&gt;运算符支持&lt;/h1&gt;&lt;p&gt;有通用运算符支持的数据类型往往更容易理解和操作，其中最讨人喜欢的莫过于&lt;code&gt;+&lt;/code&gt;运算符：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;str += str2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str = str + &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，你也可以直接调用&lt;code&gt;append&lt;/code&gt;方法：&lt;code&gt;str.append(str2)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了&lt;code&gt;+&lt;/code&gt;，&lt;code&gt;string&lt;/code&gt;还支持一系列的比较运算符：&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，你仍然可以直接调用&lt;code&gt;compare&lt;/code&gt;方法：&lt;code&gt;str1.compare(str2)&lt;/code&gt;，&lt;code&gt;str1&lt;/code&gt;小则会返回&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;长度&quot;&gt;&lt;a href=&quot;#长度&quot; class=&quot;headerlink&quot; title=&quot;长度&quot;&gt;&lt;/a&gt;长度&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;字符串为空&lt;ul&gt;
&lt;li&gt;&lt;code&gt;empty()&lt;/code&gt;：返回是否为空。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clear()&lt;/code&gt;：清空字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字符串长度&lt;ul&gt;
&lt;li&gt;&lt;code&gt;length()&lt;/code&gt;：等效于&lt;code&gt;size()&lt;/code&gt;，返回字符串长度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resize(10, &amp;#39;x&amp;#39;)&lt;/code&gt;：改变长度，如果超过了原有长度，后面补&lt;code&gt;x&lt;/code&gt;，第二个参数默认值为null。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;字符串内存&lt;ul&gt;
&lt;li&gt;&lt;code&gt;capacity()&lt;/code&gt;：无需再次申请内存可存放的字符数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reserve(10)&lt;/code&gt;：申请10字符的内存，通常在大量的&lt;code&gt;insert&lt;/code&gt;前先&lt;code&gt;reserve&lt;/code&gt;一下，避免多次申请内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;str.find(&amp;quot;ll&amp;quot;)&lt;/code&gt;：字符串&lt;code&gt;ll&lt;/code&gt;在&lt;code&gt;str&lt;/code&gt;中第一次出现的下标，未找到为&lt;code&gt;string::npos&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str.rfind(&amp;quot;ll&amp;quot;)&lt;/code&gt;：同上，从右向左查找。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str.find(&amp;quot;ll&amp;quot;, 3)&lt;/code&gt;：从下标3开始查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;修改&quot;&gt;&lt;a href=&quot;#修改&quot; class=&quot;headerlink&quot; title=&quot;修改&quot;&gt;&lt;/a&gt;修改&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;erase(5)&lt;/code&gt;：去掉下标5开始的所有字符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace(2, 3, &amp;quot;ll&amp;quot;)&lt;/code&gt;：下标2开始的3个字符换成&lt;code&gt;&amp;quot;ll&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insert(2, &amp;quot;ll&amp;quot;)&lt;/code&gt;：下标2处插入&lt;code&gt;&amp;quot;ll&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;流处理&quot;&gt;&lt;a href=&quot;#流处理&quot; class=&quot;headerlink&quot; title=&quot;流处理&quot;&gt;&lt;/a&gt;流处理&lt;/h1&gt;&lt;p&gt;在C++中，标准输入输出、文件、字符串都可以作为一个流，来接受输入或者输出。&lt;br&gt;在C++中字符串流也是格式化输出的一种常用手段。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;test 123&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;istringstream&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sinput&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(input)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sinput &amp;gt;&amp;gt; str &amp;gt;&amp;gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;ostringstream&lt;/span&gt; soutput;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;soutput &amp;lt;&amp;lt; str &amp;lt;&amp;lt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt; soutput.str();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// test123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;字符串在很多编程语言中已经成为基本数据类型，C语言中我们使用&lt;code&gt;char*&lt;/code&gt;来手动维护字符串的内存，&lt;br&gt;在C++中，可以使用&lt;code&gt;std::string&lt;/code&gt;来方便地创建和操作字符串。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;是一个模板类，它有&lt;code&gt;basic_string&amp;lt;T&amp;gt;&lt;/code&gt;定义：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; basic_string&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;&amp;gt; &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;C++的&lt;code&gt;string&lt;/code&gt;可以通过成员方法&lt;code&gt;c_str()&lt;/code&gt;转换为C语言的&lt;code&gt;char*&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;http://www.cplusplus.com/reference/string/string/&quot;&gt;cplusplus.com/string&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;初始化与赋值&quot;&gt;&lt;a href=&quot;#初始化与赋值&quot; class=&quot;headerlink&quot; title=&quot;初始化与赋值&quot;&gt;&lt;/a&gt;初始化与赋值&lt;/h1&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;有两个常用的构造函数：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 用一个C字符串构造&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 等价于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; str = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以用N个同样的字符来构造字符串：&lt;code&gt;string str2(8, &amp;#39;x&amp;#39;)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在C0x标准中，&lt;code&gt;std::to_string&lt;/code&gt;可以将很多类型转换为一个&lt;code&gt;string&lt;/code&gt;，可以代替&lt;code&gt;itoa&lt;/code&gt;，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; str = to_string(&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;构造函数不接受&lt;code&gt;char&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;字符串可以直接互相赋值，内存会自动拷贝和销毁，我们大可不必管它。对于单个字符赋值可以使用下标运算符：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;str.length(); i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str[i] = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;与多数class类似，&lt;code&gt;string&lt;/code&gt;也提供了&lt;code&gt;swap&lt;/code&gt;：&lt;code&gt;str1.swap(s2)&lt;/code&gt;将会交换二者的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;运算符支持&quot;&gt;&lt;a href=&quot;#运算符支持&quot; class=&quot;headerlink&quot; title=&quot;运算符支持&quot;&gt;&lt;/a&gt;运算符支持&lt;/h1&gt;&lt;p&gt;有通用运算符支持的数据类型往往更容易理解和操作，其中最讨人喜欢的莫过于&lt;code&gt;+&lt;/code&gt;运算符：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;str += str2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str = str + &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，你也可以直接调用&lt;code&gt;append&lt;/code&gt;方法：&lt;code&gt;str.append(str2)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了&lt;code&gt;+&lt;/code&gt;，&lt;code&gt;string&lt;/code&gt;还支持一系列的比较运算符：&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，你仍然可以直接调用&lt;code&gt;compare&lt;/code&gt;方法：&lt;code&gt;str1.compare(str2)&lt;/code&gt;，&lt;code&gt;str1&lt;/code&gt;小则会返回&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="reading" scheme="http://yunvoo.com/categories/reading/"/>
    
    
      <category term="C++ 字符串" scheme="http://yunvoo.com/tags/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>C++手稿：封装与继承</title>
    <link href="http://yunvoo.com//blog/2015/06/29/cpp-encapsulation-and-inheritance.html"/>
    <id>http://yunvoo.com//blog/2015/06/29/cpp-encapsulation-and-inheritance.html</id>
    <published>2015-06-28T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.182Z</updated>
    
    <content type="html">&lt;p&gt;本文总结了C++中类的继承相关的概念，包括可见性级别、继承的不同方式、构造与析构过程、封闭类、友元等。&lt;/p&gt;
&lt;h1 id=&quot;可见性级别&quot;&gt;&lt;a href=&quot;#可见性级别&quot; class=&quot;headerlink&quot; title=&quot;可见性级别&quot;&gt;&lt;/a&gt;可见性级别&lt;/h1&gt;&lt;p&gt;C++类提供了数据结构和算法的封装，以及相应的3种可见级别。它们定义了不同的可见性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Public：当前类以及子类的方法中可见，外部可见。&lt;/li&gt;
&lt;li&gt;Protected：当前类以及子类的方法中可见，外部不可见。&lt;/li&gt;
&lt;li&gt;Private：当前类的方法中可见，外部不可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个对象的成员函数中，可以调用其他同类对象的私有方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多数现代的面向对象语言中，仅提供Private和Public两种可见性，C++的可见级别略显复杂。&lt;br&gt;然而三种继承方式以及多继承机制，让问题更加复杂。简单起见，此处只讨论Private和Public方式的单继承。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Public继承：子类中可访问基类&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;成员，子类外部可见父类&lt;code&gt;public&lt;/code&gt;成员。&lt;/li&gt;
&lt;li&gt;Private继承：子类中可访问基类&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;成员，子类外部不可见父类成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;类的继承&quot;&gt;&lt;a href=&quot;#类的继承&quot; class=&quot;headerlink&quot; title=&quot;类的继承&quot;&gt;&lt;/a&gt;类的继承&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Public继承表示”is a”的关系（见&lt;a href=&quot;!--￼6--&quot;&gt;Effective C++: Item 32&lt;/a&gt;），子类的对象同时也是一个基类的对象。&lt;br&gt;子类的行为应符合基类的行为，因此Public继承中通常不会覆盖基类成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Private继承表示“以…实现“的关系，子类是以基类来实现的&lt;br&gt;对于一个子类的对象，其外部不可见基类的行为。Private继承更像是对象组合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对于Public继承，子类的指针、引用、变量可以直接赋值给基类的指针、引用、变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CBase&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CDerived: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CBase&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CDerived(): CBase()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;名称隐藏&quot;&gt;&lt;a href=&quot;#名称隐藏&quot; class=&quot;headerlink&quot; title=&quot;名称隐藏&quot;&gt;&lt;/a&gt;名称隐藏&lt;/h1&gt;&lt;p&gt;子类中声明的成员会覆盖掉基类中的同名成员，但可以通过基类名来调用：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CBase&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CDerived: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CBase&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CBase::i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;与访问成员变量的方式类似，访问基类的成员函数的也需要指定基类名称。类继承引起的名称隐藏和作用域嵌套引起的名称隐藏是一样的，隐藏的是名称与类型无关。&lt;br&gt;更多讨论可以参见&lt;a href=&quot;!--￼7--&quot;&gt;Effective C++: Item 33&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;封闭类&quot;&gt;&lt;a href=&quot;#封闭类&quot; class=&quot;headerlink&quot; title=&quot;封闭类&quot;&gt;&lt;/a&gt;封闭类&lt;/h1&gt;&lt;p&gt;有成员对象的类称为&lt;strong&gt;封闭类&lt;/strong&gt;，这是对象组合的一种实现方式。可以在构造函数的初始化列表中进行初始化。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CHead head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CBody body;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CPerson(head_, body_):head(head_), body(_body)&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;很显然，如果对象成员的构造函数参数非空，则会要求当前类指定构造函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可以不指定初始化列表，在构造函数中再进行成员对象的赋值，这会导致成员对象被构造多次。&lt;br&gt;更重要的是，因为&lt;strong&gt;常量类型、引用类型的成员不接受赋值，它们只能在初始化列表中进行初始化&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;构造与析构过程&quot;&gt;&lt;a href=&quot;#构造与析构过程&quot; class=&quot;headerlink&quot; title=&quot;构造与析构过程&quot;&gt;&lt;/a&gt;构造与析构过程&lt;/h1&gt;&lt;p&gt;对象的构造过程中，首先完成父类的构造函数，再完成成员对象的构造，最后调用当前类的构造函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造父类的对象。在此过程中对象的动态类型是仍然是父类。&lt;/li&gt;
&lt;li&gt;构造对象属性。它们实例化的顺序只取决于在类中声明的顺序，与初始化列表中的顺序无关。&lt;/li&gt;
&lt;li&gt;调用构造函数。在这里完成当前类指定的构造过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对象的析构过程恰好相反，首先调用当前类的析构函数，然后析构对象属性，最后析构父类对象。&lt;/p&gt;
&lt;h1 id=&quot;友元&quot;&gt;&lt;a href=&quot;#友元&quot; class=&quot;headerlink&quot; title=&quot;友元&quot;&gt;&lt;/a&gt;友元&lt;/h1&gt;&lt;p&gt;C++中存在着破坏封装的语法特性：友元，友元函数和友元类可以访问当前类的私有成员。但通过友元可以更好地实现类的扩展和运算符重载。&lt;br&gt;&lt;a href=&quot;!--￼5--&quot;&gt;Effective C++: Item 23&lt;/a&gt;给出了更多关于友元和封装的讨论。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;友元的关系不可传递和继承。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;友元函数在类声明中添加&lt;code&gt;friend&lt;/code&gt;关键字，可以通过参数传入类的实例进行操作。友元函数也可以是另一个类的成员函数。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SetAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CPerson&amp;amp;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CGod::createMan();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SetAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CPerson&amp;amp; p, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p.age = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;友元类的逻辑相对简单，在声明中给出友元类，便给了它私有的权限：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; God;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了C++中类的继承相关的概念，包括可见性级别、继承的不同方式、构造与析构过程、封闭类、友元等。&lt;/p&gt;
&lt;h1 id=&quot;可见性级别&quot;&gt;&lt;a href=&quot;#可见性级别&quot; class=&quot;headerlink&quot; title=&quot;可见性级别&quot;&gt;&lt;/a&gt;可见性级别&lt;/h1&gt;&lt;p&gt;C++类提供了数据结构和算法的封装，以及相应的3种可见级别。它们定义了不同的可见性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Public：当前类以及子类的方法中可见，外部可见。&lt;/li&gt;
&lt;li&gt;Protected：当前类以及子类的方法中可见，外部不可见。&lt;/li&gt;
&lt;li&gt;Private：当前类的方法中可见，外部不可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个对象的成员函数中，可以调用其他同类对象的私有方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多数现代的面向对象语言中，仅提供Private和Public两种可见性，C++的可见级别略显复杂。&lt;br&gt;然而三种继承方式以及多继承机制，让问题更加复杂。简单起见，此处只讨论Private和Public方式的单继承。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Public继承：子类中可访问基类&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;成员，子类外部可见父类&lt;code&gt;public&lt;/code&gt;成员。&lt;/li&gt;
&lt;li&gt;Private继承：子类中可访问基类&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;成员，子类外部不可见父类成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;类的继承&quot;&gt;&lt;a href=&quot;#类的继承&quot; class=&quot;headerlink&quot; title=&quot;类的继承&quot;&gt;&lt;/a&gt;类的继承&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Public继承表示”is a”的关系（见&lt;a href=&quot;!--￼6--&quot;&gt;Effective C++: Item 32&lt;/a&gt;），子类的对象同时也是一个基类的对象。&lt;br&gt;子类的行为应符合基类的行为，因此Public继承中通常不会覆盖基类成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Private继承表示“以…实现“的关系，子类是以基类来实现的&lt;br&gt;对于一个子类的对象，其外部不可见基类的行为。Private继承更像是对象组合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对于Public继承，子类的指针、引用、变量可以直接赋值给基类的指针、引用、变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CBase&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CDerived: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CBase&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CDerived(): CBase()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C++ 封装 继承 作用域 多继承 名称隐藏 对象组合 构造函数 析构函数" scheme="http://yunvoo.com/tags/C-%E5%B0%81%E8%A3%85-%E7%BB%A7%E6%89%BF-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%A4%9A%E7%BB%A7%E6%89%BF-%E5%90%8D%E7%A7%B0%E9%9A%90%E8%97%8F-%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++手稿：虚函数与多态</title>
    <link href="http://yunvoo.com//blog/2015/06/28/cpp-polymorphism.html"/>
    <id>http://yunvoo.com//blog/2015/06/28/cpp-polymorphism.html</id>
    <published>2015-06-27T16:00:00.000Z</published>
    <updated>2016-06-18T04:06:03.193Z</updated>
    
    <content type="html">&lt;p&gt;C++类继承带来了诸多好处：基类代码复用、通用的方法和属性、更好的可维护性，&lt;br&gt;然而最大的好处莫过于提供统一的接口。接口是一种对类型的抽象，它统一了一系列类的行为，&lt;br&gt;不同类的对象之间交互更加容易。Java、objective C等面向对象语言都提供了接口的概念，&lt;br&gt;在C++中可以通过抽象类来模拟接口的行为。&lt;/p&gt;
&lt;p&gt;与此同时，C++通过虚函数实现了多态：通过基类指针或引用调用虚函数时，会调用当前对象的实际类型中声明的函数。&lt;br&gt;为了这个特性，包含虚函数的C++对象中会存储一个虚函数表指针，来完成动态联编。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译程序在编译阶段并不能确切知道将要调用的函数，只有在程序运行时才能确定将要调用的函数，&lt;br&gt;为此要确切知道该调用的函数，要求联编工作要在程序运行时进行，&lt;br&gt;这种在程序运行时进行联编工作被称为&lt;strong&gt;动态联编&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;虚函数&quot;&gt;&lt;a href=&quot;#虚函数&quot; class=&quot;headerlink&quot; title=&quot;虚函数&quot;&gt;&lt;/a&gt;虚函数&lt;/h1&gt;&lt;p&gt;虚函数通过&lt;code&gt;virtual&lt;/code&gt;关键字来声明。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m a person&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CMan: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 子类中不必声明virtual&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m a man&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPerson *p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CMan();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p-&amp;gt;hello();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// I&#39;m a man&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码中，通过基类指针调用虚函数时，子类的同名函数得到了执行。多态在C++中有三种形态：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过基类指针调用基类和子类的同名虚函数时，会调用对象的实际类型中的虚函数。&lt;/li&gt;
&lt;li&gt;通过基类引用调用基类和子类的同名虚函数时，会调用对象的实际类型中的虚函数。&lt;/li&gt;
&lt;li&gt;基类或子类的成员函数中调用基类和子类的同名虚函数，会调用对象的实际类型中的虚函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;纯虚函数&quot;&gt;&lt;a href=&quot;#纯虚函数&quot; class=&quot;headerlink&quot; title=&quot;纯虚函数&quot;&gt;&lt;/a&gt;纯虚函数&lt;/h1&gt;&lt;p&gt;虚函数的声明以&lt;code&gt;=0&lt;/code&gt;结束，便可将它声明为纯虚函数。包含纯虚函数的类不允许实例化，称为&lt;strong&gt;抽象类&lt;/strong&gt;。&lt;br&gt;事实上纯虚函数提供了面向对象中接口的功能。当然，这样的接口是以继承的方式实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPerson p;  &lt;span class=&quot;comment&quot;&gt;// compile error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意空方法、纯虚函数、方法声明的区别。类声明中的空方法给出了方法声明+方法定义。&lt;br&gt;只声明但没有定义的方法将会产生链接错，无论是否被调用过。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;declare&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPerson::declare()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;访问级别&quot;&gt;&lt;a href=&quot;#访问级别&quot; class=&quot;headerlink&quot; title=&quot;访问级别&quot;&gt;&lt;/a&gt;访问级别&lt;/h1&gt;&lt;p&gt;虚函数的调用会在运行时动态匹配当前类型，然而成员函数的访问性检查是语法检查的一部分，在编译期完成。&lt;br&gt;如果虚函数在父类中是Private，即使在子类中是Public，也不可以通过父类指针调用它：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CMan: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPerson* p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CMan;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p-&amp;gt;hello(); &lt;span class=&quot;comment&quot;&gt;// 编译错&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;虚析构函数&quot;&gt;&lt;a href=&quot;#虚析构函数&quot; class=&quot;headerlink&quot; title=&quot;虚析构函数&quot;&gt;&lt;/a&gt;虚析构函数&lt;/h1&gt;&lt;p&gt;虚函数的机制使得我们可以通过更加通用的基类指针来操作对象。然而使用基类指针来&lt;code&gt;delete&lt;/code&gt;对象则面临着问题：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CPerson *p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CMan();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码只会回收&lt;code&gt;CMan&lt;/code&gt;中&lt;code&gt;CPerson&lt;/code&gt;部分所占用的内存，执行了&lt;code&gt;CPerson&lt;/code&gt;的析构函数，却没有执行&lt;code&gt;CMan&lt;/code&gt;的虚构函数。&lt;br&gt;解决办法很直观：将析构函数设为&lt;code&gt;virtual&lt;/code&gt;。更多讨论见&lt;a href=&quot;!--￼8--&quot;&gt;Effective C++: Item 7&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构造函数不允许是虚函数，编译错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; ~CPerson()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CMan: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~CMan()&amp;#123;&amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CPerson *p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CMan();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; p;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，&lt;code&gt;delete&lt;/code&gt;时会先调用&lt;code&gt;~CMan()&lt;/code&gt;在调用&lt;code&gt;~CPerson()&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;构造函数调用虚函数&quot;&gt;&lt;a href=&quot;#构造函数调用虚函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数调用虚函数&quot;&gt;&lt;/a&gt;构造函数调用虚函数&lt;/h1&gt;&lt;p&gt;当执行构造函数时，当前对象的类型为构造函数所属在的类。&lt;br&gt;所以在构造函数中调用虚函数和调用普通函数是一样的，不会动态联编，&lt;br&gt;被调用的函数来自自己或者基类。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m a person&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bye&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;Bye, person&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CMan: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CPerson&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CMan()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hello();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bye();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m a man&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CReek: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; CMan&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m a reek&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bye&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&quot;Bye, reek&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CReek r;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述的调用结果是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;I&amp;apos;m a man&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bye, person&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;hello&lt;/code&gt;和&lt;code&gt;bye&lt;/code&gt;都是虚函数，其中&lt;code&gt;hello&lt;/code&gt;三个层级都有定义，但被执行的是当前类&lt;code&gt;CMan&lt;/code&gt;中的定义；&lt;br&gt;&lt;code&gt;bye&lt;/code&gt;在上下两个层级有定义，被执行的是上一级类&lt;code&gt;CPerson&lt;/code&gt;中的定义。&lt;br&gt;可见，构造函数执行时当前对象的类型是定义构造函数的类。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;C++类继承带来了诸多好处：基类代码复用、通用的方法和属性、更好的可维护性，&lt;br&gt;然而最大的好处莫过于提供统一的接口。接口是一种对类型的抽象，它统一了一系列类的行为，&lt;br&gt;不同类的对象之间交互更加容易。Java、objective C等面向对象语言都提供了接口的概念，&lt;
    
    </summary>
    
    
      <category term="C++ 多态 引用 指针 继承 虚函数 成员函数 构造函数 析构函数" scheme="http://yunvoo.com/tags/C-%E5%A4%9A%E6%80%81-%E5%BC%95%E7%94%A8-%E6%8C%87%E9%92%88-%E7%BB%A7%E6%89%BF-%E8%99%9A%E5%87%BD%E6%95%B0-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
